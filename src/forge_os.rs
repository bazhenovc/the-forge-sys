/* automatically generated by rust-bindgen 0.59.1 */

pub const FS_MAX_PATH: u32 = 256;
pub const HIRES_TIMER_LENGTH_OF_HISTORY: u32 = 60;
pub type size_t = u64;
pub type ssize_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FILE {
    _unused: [u8; 0],
}
extern "C" {
    pub fn initMemAlloc(appName: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn exitMemAlloc();
}
extern "C" {
    pub fn tf_malloc_internal(
        size: size_t,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
        sf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn tf_memalign_internal(
        align: size_t,
        size: size_t,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
        sf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn tf_calloc_internal(
        count: size_t,
        size: size_t,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
        sf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn tf_calloc_memalign_internal(
        count: size_t,
        align: size_t,
        size: size_t,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
        sf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn tf_realloc_internal(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
        sf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn tf_free_internal(
        ptr: *mut ::std::os::raw::c_void,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
        sf: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowHandle {
    pub window: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_WindowHandle() {
    assert_eq!(
        ::std::mem::size_of::<WindowHandle>(),
        8usize,
        concat!("Size of: ", stringify!(WindowHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowHandle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowHandle>())).window as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(WindowHandle), "::", stringify!(window))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RectDesc {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_RectDesc() {
    assert_eq!(
        ::std::mem::size_of::<RectDesc>(),
        16usize,
        concat!("Size of: ", stringify!(RectDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RectDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(RectDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RectDesc>())).left as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(RectDesc), "::", stringify!(left))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RectDesc>())).top as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(RectDesc), "::", stringify!(top))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RectDesc>())).right as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(RectDesc), "::", stringify!(right))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RectDesc>())).bottom as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(RectDesc), "::", stringify!(bottom))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowsDesc {
    pub handle: WindowHandle,
    pub windowedRect: RectDesc,
    pub fullscreenRect: RectDesc,
    pub clientRect: RectDesc,
    pub windowsFlags: u32,
    pub fullScreen: bool,
    pub cursorTracked: bool,
    pub iconified: bool,
    pub maximized: bool,
    pub minimized: bool,
    pub hide: bool,
    pub noresizeFrame: bool,
    pub borderlessWindow: bool,
    pub overrideDefaultPosition: bool,
    pub centered: bool,
    pub forceLowDPI: bool,
}
#[test]
fn bindgen_test_layout_WindowsDesc() {
    assert_eq!(
        ::std::mem::size_of::<WindowsDesc>(),
        72usize,
        concat!("Size of: ", stringify!(WindowsDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowsDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowsDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).handle as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(WindowsDesc), "::", stringify!(handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).windowedRect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(windowedRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).fullscreenRect as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(fullscreenRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).clientRect as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(clientRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).windowsFlags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(windowsFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).fullScreen as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(fullScreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).cursorTracked as *const _ as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(cursorTracked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).iconified as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(iconified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).maximized as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(maximized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).minimized as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(minimized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).hide as *const _ as usize },
        65usize,
        concat!("Offset of field: ", stringify!(WindowsDesc), "::", stringify!(hide))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).noresizeFrame as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(noresizeFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).borderlessWindow as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(borderlessWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).overrideDefaultPosition as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(overrideDefaultPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).centered as *const _ as usize },
        69usize,
        concat!("Offset of field: ", stringify!(WindowsDesc), "::", stringify!(centered))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowsDesc>())).forceLowDPI as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowsDesc),
            "::",
            stringify!(forceLowDPI)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Resolution {
    pub mWidth: u32,
    pub mHeight: u32,
}
#[test]
fn bindgen_test_layout_Resolution() {
    assert_eq!(
        ::std::mem::size_of::<Resolution>(),
        8usize,
        concat!("Size of: ", stringify!(Resolution))
    );
    assert_eq!(
        ::std::mem::align_of::<Resolution>(),
        4usize,
        concat!("Alignment of ", stringify!(Resolution))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Resolution>())).mWidth as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Resolution), "::", stringify!(mWidth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Resolution>())).mHeight as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Resolution), "::", stringify!(mHeight))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MonitorDesc {
    pub monitorRect: RectDesc,
    pub workRect: RectDesc,
    pub dpi: [::std::os::raw::c_uint; 2usize],
    pub physicalSize: [::std::os::raw::c_uint; 2usize],
    pub adapterName: [::std::os::raw::c_char; 32usize],
    pub displayName: [::std::os::raw::c_char; 32usize],
    pub publicAdapterName: [::std::os::raw::c_char; 64usize],
    pub publicDisplayName: [::std::os::raw::c_char; 64usize],
    pub resolutions: *mut Resolution,
    pub defaultResolution: Resolution,
    pub resolutionCount: u32,
    pub modesPruned: bool,
    pub modeChanged: bool,
}
#[test]
fn bindgen_test_layout_MonitorDesc() {
    assert_eq!(
        ::std::mem::size_of::<MonitorDesc>(),
        264usize,
        concat!("Size of: ", stringify!(MonitorDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<MonitorDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(MonitorDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).monitorRect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(monitorRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).workRect as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MonitorDesc), "::", stringify!(workRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).dpi as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(MonitorDesc), "::", stringify!(dpi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).physicalSize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(physicalSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).adapterName as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(adapterName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).displayName as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(displayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).publicAdapterName as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(publicAdapterName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).publicDisplayName as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(publicDisplayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).resolutions as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(resolutions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).defaultResolution as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(defaultResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).resolutionCount as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(resolutionCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).modesPruned as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(modesPruned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorDesc>())).modeChanged as *const _ as usize },
        261usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorDesc),
            "::",
            stringify!(modeChanged)
        )
    );
}
pub const ResetScenario_RESET_SCENARIO_NONE: ResetScenario = 0;
pub const ResetScenario_RESET_SCENARIO_RELOAD: ResetScenario = 1;
pub type ResetScenario = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}?onRequestReload@@YAXXZ"]
    pub fn onRequestReload();
}
extern "C" {
    #[link_name = "\u{1}?onDeviceLost@@YAXXZ"]
    pub fn onDeviceLost();
}
extern "C" {
    #[link_name = "\u{1}?onAPISwitch@@YAXXZ"]
    pub fn onAPISwitch();
}
extern "C" {
    #[link_name = "\u{1}?requestShutdown@@YAXXZ"]
    pub fn requestShutdown();
}
extern "C" {
    #[link_name = "\u{1}?errorMessagePopup@@YAXPEBD0PEAX@Z"]
    pub fn errorMessagePopup(
        title: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
        windowHandle: *mut ::std::os::raw::c_void,
    );
}
pub type CustomMessageProcessor =
    ::std::option::Option<unsafe extern "C" fn(pWindow: *mut WindowsDesc, msg: *mut ::std::os::raw::c_void) -> i32>;
extern "C" {
    #[link_name = "\u{1}?setCustomMessageProcessor@@YAXP6AHPEAUWindowsDesc@@PEAX@Z@Z"]
    pub fn setCustomMessageProcessor(proc_: CustomMessageProcessor);
}
extern "C" {
    #[link_name = "\u{1}?openWindow@@YAXPEBDPEAUWindowsDesc@@@Z"]
    pub fn openWindow(app_name: *const ::std::os::raw::c_char, winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?closeWindow@@YAXPEBUWindowsDesc@@@Z"]
    pub fn closeWindow(winDesc: *const WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?setWindowRect@@YAXPEAUWindowsDesc@@PEBURectDesc@@@Z"]
    pub fn setWindowRect(winDesc: *mut WindowsDesc, rect: *const RectDesc);
}
extern "C" {
    #[link_name = "\u{1}?setWindowSize@@YAXPEAUWindowsDesc@@II@Z"]
    pub fn setWindowSize(winDesc: *mut WindowsDesc, width: ::std::os::raw::c_uint, height: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}?toggleBorderless@@YAXPEAUWindowsDesc@@II@Z"]
    pub fn toggleBorderless(winDesc: *mut WindowsDesc, width: ::std::os::raw::c_uint, height: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}?toggleFullscreen@@YAXPEAUWindowsDesc@@@Z"]
    pub fn toggleFullscreen(winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?showWindow@@YAXPEAUWindowsDesc@@@Z"]
    pub fn showWindow(winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?hideWindow@@YAXPEAUWindowsDesc@@@Z"]
    pub fn hideWindow(winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?maximizeWindow@@YAXPEAUWindowsDesc@@@Z"]
    pub fn maximizeWindow(winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?minimizeWindow@@YAXPEAUWindowsDesc@@@Z"]
    pub fn minimizeWindow(winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?centerWindow@@YAXPEAUWindowsDesc@@@Z"]
    pub fn centerWindow(winDesc: *mut WindowsDesc);
}
extern "C" {
    #[link_name = "\u{1}?createCursor@@YAPEAXPEBD@Z"]
    pub fn createCursor(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?setCursor@@YAXPEAX@Z"]
    pub fn setCursor(cursor: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?showCursor@@YAXXZ"]
    pub fn showCursor();
}
extern "C" {
    #[link_name = "\u{1}?hideCursor@@YAXXZ"]
    pub fn hideCursor();
}
extern "C" {
    #[link_name = "\u{1}?isCursorInsideTrackingArea@@YA_NXZ"]
    pub fn isCursorInsideTrackingArea() -> bool;
}
extern "C" {
    #[link_name = "\u{1}?setMousePositionRelative@@YAXPEBUWindowsDesc@@HH@Z"]
    pub fn setMousePositionRelative(winDesc: *const WindowsDesc, x: i32, y: i32);
}
extern "C" {
    #[link_name = "\u{1}?setMousePositionAbsolute@@YAXHH@Z"]
    pub fn setMousePositionAbsolute(x: i32, y: i32);
}
extern "C" {
    #[link_name = "\u{1}?getRecommendedResolution@@YAXPEAURectDesc@@@Z"]
    pub fn getRecommendedResolution(rect: *mut RectDesc);
}
extern "C" {
    #[link_name = "\u{1}?setResolution@@YAXPEBUMonitorDesc@@PEBUResolution@@@Z"]
    pub fn setResolution(pMonitor: *const MonitorDesc, pRes: *const Resolution);
}
extern "C" {
    #[link_name = "\u{1}?getMonitor@@YAPEAUMonitorDesc@@I@Z"]
    pub fn getMonitor(index: u32) -> *mut MonitorDesc;
}
extern "C" {
    #[link_name = "\u{1}?getMonitorCount@@YAIXZ"]
    pub fn getMonitorCount() -> u32;
}
extern "C" {
    #[link_name = "\u{1}?getDpiScale@@YAXQEAM@Z"]
    pub fn getDpiScale(array: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}?getResolutionSupport@@YA_NPEBUMonitorDesc@@PEBUResolution@@@Z"]
    pub fn getResolutionSupport(pMonitor: *const MonitorDesc, pRes: *const Resolution) -> bool;
}
extern "C" {
    #[doc = " @param stdOutFile The file to which the output of the command should be written. May be NULL."]
    #[link_name = "\u{1}?systemRun@@YAHPEBDPEAPEBD_K0@Z"]
    pub fn systemRun(
        command: *const ::std::os::raw::c_char,
        arguments: *mut *const ::std::os::raw::c_char,
        argumentCount: size_t,
        stdOutFile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Installed game directory / bundle resource directory"]
pub const ResourceMount_RM_CONTENT: ResourceMount = 0;
#[doc = " For storing debug data such as log files. To be used only during development"]
pub const ResourceMount_RM_DEBUG: ResourceMount = 1;
#[doc = " Documents directory"]
pub const ResourceMount_RM_DOCUMENTS: ResourceMount = 2;
#[doc = " Save game data mount 0"]
pub const ResourceMount_RM_SAVE_0: ResourceMount = 3;
#[doc = " Save game data mount 0"]
pub const ResourceMount_RM_COUNT: ResourceMount = 4;
pub type ResourceMount = ::std::os::raw::c_int;
#[doc = " The main application's shader binaries directory"]
pub const ResourceDirectory_RD_SHADER_BINARIES: ResourceDirectory = 0;
#[doc = " The main application's shader source directory"]
pub const ResourceDirectory_RD_SHADER_SOURCES: ResourceDirectory = 1;
#[doc = " The main application's shader source directory"]
pub const ResourceDirectory_RD_PIPELINE_CACHE: ResourceDirectory = 2;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_TEXTURES: ResourceDirectory = 3;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MESHES: ResourceDirectory = 4;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_FONTS: ResourceDirectory = 5;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_ANIMATIONS: ResourceDirectory = 6;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_AUDIO: ResourceDirectory = 7;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_GPU_CONFIG: ResourceDirectory = 8;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_LOG: ResourceDirectory = 9;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_SCRIPTS: ResourceDirectory = 10;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_SCREENSHOTS: ResourceDirectory = 11;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_OTHER_FILES: ResourceDirectory = 12;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_____rd_lib_counter_begin: ResourceDirectory = 13;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_0: ResourceDirectory = 13;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_1: ResourceDirectory = 14;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_2: ResourceDirectory = 15;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_3: ResourceDirectory = 16;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_4: ResourceDirectory = 17;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_5: ResourceDirectory = 18;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_6: ResourceDirectory = 19;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_7: ResourceDirectory = 20;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_8: ResourceDirectory = 21;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_9: ResourceDirectory = 22;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_10: ResourceDirectory = 23;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_11: ResourceDirectory = 24;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_12: ResourceDirectory = 25;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_13: ResourceDirectory = 26;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_14: ResourceDirectory = 27;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_MIDDLEWARE_15: ResourceDirectory = 28;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_____rd_lib_counter_end: ResourceDirectory = 211;
#[doc = " The main application's texture source directory (TODO processed texture folder)"]
pub const ResourceDirectory_RD_COUNT: ResourceDirectory = 212;
pub type ResourceDirectory = ::std::os::raw::c_int;
pub const SeekBaseOffset_SBO_START_OF_FILE: SeekBaseOffset = 0;
pub const SeekBaseOffset_SBO_CURRENT_POSITION: SeekBaseOffset = 1;
pub const SeekBaseOffset_SBO_END_OF_FILE: SeekBaseOffset = 2;
pub type SeekBaseOffset = ::std::os::raw::c_int;
pub const FileMode_FM_READ: FileMode = 1;
pub const FileMode_FM_WRITE: FileMode = 2;
pub const FileMode_FM_APPEND: FileMode = 4;
pub const FileMode_FM_BINARY: FileMode = 8;
pub const FileMode_FM_ALLOW_READ: FileMode = 16;
pub const FileMode_FM_READ_WRITE: FileMode = 3;
pub const FileMode_FM_READ_APPEND: FileMode = 5;
pub const FileMode_FM_WRITE_BINARY: FileMode = 10;
pub const FileMode_FM_READ_BINARY: FileMode = 9;
pub const FileMode_FM_APPEND_BINARY: FileMode = 12;
pub const FileMode_FM_READ_WRITE_BINARY: FileMode = 11;
pub const FileMode_FM_READ_APPEND_BINARY: FileMode = 13;
pub const FileMode_FM_WRITE_ALLOW_READ: FileMode = 18;
pub const FileMode_FM_APPEND_ALLOW_READ: FileMode = 17;
pub const FileMode_FM_READ_WRITE_ALLOW_READ: FileMode = 19;
pub const FileMode_FM_READ_APPEND_ALLOW_READ: FileMode = 21;
pub const FileMode_FM_WRITE_BINARY_ALLOW_READ: FileMode = 26;
pub const FileMode_FM_APPEND_BINARY_ALLOW_READ: FileMode = 28;
pub const FileMode_FM_READ_WRITE_BINARY_ALLOW_READ: FileMode = 27;
pub const FileMode_FM_READ_APPEND_BINARY_ALLOW_READ: FileMode = 29;
pub type FileMode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryStream {
    pub pBuffer: *mut u8,
    pub mCursor: size_t,
    pub mCapacity: size_t,
    pub mOwner: bool,
}
#[test]
fn bindgen_test_layout_MemoryStream() {
    assert_eq!(
        ::std::mem::size_of::<MemoryStream>(),
        32usize,
        concat!("Size of: ", stringify!(MemoryStream))
    );
    assert_eq!(
        ::std::mem::align_of::<MemoryStream>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryStream>())).pBuffer as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MemoryStream), "::", stringify!(pBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryStream>())).mCursor as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MemoryStream), "::", stringify!(mCursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryStream>())).mCapacity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryStream),
            "::",
            stringify!(mCapacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryStream>())).mOwner as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(MemoryStream), "::", stringify!(mOwner))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FileStream {
    pub pIO: *mut IFileSystem,
    pub pBase: *mut FileStream,
    pub __bindgen_anon_1: FileStream__bindgen_ty_1,
    pub mSize: ssize_t,
    pub mMode: FileMode,
    pub mMount: ResourceMount,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FileStream__bindgen_ty_1 {
    pub pFile: *mut FILE,
    pub mMemory: MemoryStream,
    pub pUser: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FileStream__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FileStream__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(FileStream__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<FileStream__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(FileStream__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream__bindgen_ty_1>())).pFile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileStream__bindgen_ty_1),
            "::",
            stringify!(pFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream__bindgen_ty_1>())).mMemory as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileStream__bindgen_ty_1),
            "::",
            stringify!(mMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream__bindgen_ty_1>())).pUser as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileStream__bindgen_ty_1),
            "::",
            stringify!(pUser)
        )
    );
}
#[test]
fn bindgen_test_layout_FileStream() {
    assert_eq!(
        ::std::mem::size_of::<FileStream>(),
        64usize,
        concat!("Size of: ", stringify!(FileStream))
    );
    assert_eq!(
        ::std::mem::align_of::<FileStream>(),
        8usize,
        concat!("Alignment of ", stringify!(FileStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream>())).pIO as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FileStream), "::", stringify!(pIO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream>())).pBase as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(FileStream), "::", stringify!(pBase))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream>())).mSize as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(FileStream), "::", stringify!(mSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream>())).mMode as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(FileStream), "::", stringify!(mMode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileStream>())).mMount as *const _ as usize },
        60usize,
        concat!("Offset of field: ", stringify!(FileStream), "::", stringify!(mMount))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileSystemInitDesc {
    pub pAppName: *const ::std::os::raw::c_char,
    pub pPlatformData: *mut ::std::os::raw::c_void,
    pub pResourceMounts: [*const ::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_FileSystemInitDesc() {
    assert_eq!(
        ::std::mem::size_of::<FileSystemInitDesc>(),
        48usize,
        concat!("Size of: ", stringify!(FileSystemInitDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<FileSystemInitDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(FileSystemInitDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileSystemInitDesc>())).pAppName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileSystemInitDesc),
            "::",
            stringify!(pAppName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileSystemInitDesc>())).pPlatformData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FileSystemInitDesc),
            "::",
            stringify!(pPlatformData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FileSystemInitDesc>())).pResourceMounts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FileSystemInitDesc),
            "::",
            stringify!(pResourceMounts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IFileSystem {
    pub Open: ::std::option::Option<
        unsafe extern "C" fn(
            pIO: *mut IFileSystem,
            resourceDir: ResourceDirectory,
            fileName: *const ::std::os::raw::c_char,
            mode: FileMode,
            password: *const ::std::os::raw::c_char,
            pOut: *mut FileStream,
        ) -> bool,
    >,
    pub Close: ::std::option::Option<unsafe extern "C" fn(pFile: *mut FileStream) -> bool>,
    pub Read: ::std::option::Option<
        unsafe extern "C" fn(
            pFile: *mut FileStream,
            outputBuffer: *mut ::std::os::raw::c_void,
            bufferSizeInBytes: size_t,
        ) -> size_t,
    >,
    pub Write: ::std::option::Option<
        unsafe extern "C" fn(
            pFile: *mut FileStream,
            sourceBuffer: *const ::std::os::raw::c_void,
            byteCount: size_t,
        ) -> size_t,
    >,
    pub Seek: ::std::option::Option<
        unsafe extern "C" fn(pFile: *mut FileStream, baseOffset: SeekBaseOffset, seekOffset: ssize_t) -> bool,
    >,
    pub GetSeekPosition: ::std::option::Option<unsafe extern "C" fn(pFile: *const FileStream) -> ssize_t>,
    pub GetFileSize: ::std::option::Option<unsafe extern "C" fn(pFile: *const FileStream) -> ssize_t>,
    pub Flush: ::std::option::Option<unsafe extern "C" fn(pFile: *mut FileStream) -> bool>,
    pub IsAtEnd: ::std::option::Option<unsafe extern "C" fn(pFile: *const FileStream) -> bool>,
    pub GetResourceMount:
        ::std::option::Option<unsafe extern "C" fn(mount: ResourceMount) -> *const ::std::os::raw::c_char>,
    pub GetPropInt64:
        ::std::option::Option<unsafe extern "C" fn(pFile: *mut FileStream, prop: i32, pValue: *mut i64) -> bool>,
    pub SetPropInt64:
        ::std::option::Option<unsafe extern "C" fn(pFile: *mut FileStream, prop: i32, value: i64) -> bool>,
    pub pUser: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_IFileSystem() {
    assert_eq!(
        ::std::mem::size_of::<IFileSystem>(),
        104usize,
        concat!("Size of: ", stringify!(IFileSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<IFileSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(IFileSystem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).Open as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(Open))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).Close as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(Close))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).Read as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(Read))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).Write as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(Write))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).Seek as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(Seek))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).GetSeekPosition as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IFileSystem),
            "::",
            stringify!(GetSeekPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).GetFileSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IFileSystem),
            "::",
            stringify!(GetFileSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).Flush as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(Flush))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).IsAtEnd as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(IsAtEnd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).GetResourceMount as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IFileSystem),
            "::",
            stringify!(GetResourceMount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).GetPropInt64 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IFileSystem),
            "::",
            stringify!(GetPropInt64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).SetPropInt64 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IFileSystem),
            "::",
            stringify!(SetPropInt64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IFileSystem>())).pUser as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(IFileSystem), "::", stringify!(pUser))
    );
}
extern "C" {
    #[doc = " Default file system using C File IO or Bundled File IO (Android) based on the ResourceDirectory"]
    pub static mut pSystemFileIO: *mut IFileSystem;
}
extern "C" {
    pub fn initFileSystem(pDesc: *mut FileSystemInitDesc) -> bool;
}
extern "C" {
    #[doc = " Frees resources associated with the FileSystem API"]
    pub fn exitFileSystem();
}
extern "C" {
    pub fn initZipFileSystem(
        resourceDir: ResourceDirectory,
        fileName: *const ::std::os::raw::c_char,
        mode: FileMode,
        password: *const ::std::os::raw::c_char,
        pOut: *mut IFileSystem,
    ) -> bool;
}
extern "C" {
    #[doc = " Frees resources associated with the zip file"]
    pub fn exitZipFileSystem(pZip: *mut IFileSystem) -> bool;
}
extern "C" {
    #[doc = " Fetches number of entries in zip file"]
    pub fn fsEntryCountZipFile(pIO: *mut IFileSystem, pOut: *mut u64) -> bool;
}
extern "C" {
    #[doc = " Opens zip entry by it's index in the zip file"]
    pub fn fsOpenZipEntryByIndex(
        pIO: *mut IFileSystem,
        index: u64,
        mode: FileMode,
        filePassword: *const ::std::os::raw::c_char,
        pOut: *mut FileStream,
    ) -> bool;
}
extern "C" {
    #[doc = " Reopens file handle if open entry counter was 0 and increments the counter"]
    pub fn fsOpenZipFile(pIO: *mut IFileSystem) -> bool;
}
extern "C" {
    #[doc = " Decrements open entry counter and closes file handle if it reaches 0"]
    pub fn fsCloseZipFile(pIO: *mut IFileSystem) -> bool;
}
extern "C" {
    #[doc = " Fetches zip file index from it's filename"]
    pub fn fsFetchZipEntryIndex(
        pIO: *mut IFileSystem,
        resourceDir: ResourceDirectory,
        pFileName: *const ::std::os::raw::c_char,
        pOut: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Fills pSize with the size of the filename of the entry with the given index"]
    #[doc = " If pBuffer is not NULL fills up to bufferSize - 1 bytes with filename"]
    #[doc = " the last byte of pBuffer is filled with null terminator"]
    pub fn fsFetchZipEntryName(
        pIO: *mut IFileSystem,
        index: u64,
        pBuffer: *mut ::std::os::raw::c_char,
        pSize: *mut size_t,
        bufferSize: size_t,
    ) -> bool;
}
extern "C" {
    pub fn fsOpenStreamFromPath(
        resourceDir: ResourceDirectory,
        fileName: *const ::std::os::raw::c_char,
        mode: FileMode,
        password: *const ::std::os::raw::c_char,
        pOut: *mut FileStream,
    ) -> bool;
}
extern "C" {
    #[doc = " Opens a memory buffer as a FileStream, returning a stream that must be closed with `fsCloseStream`."]
    pub fn fsOpenStreamFromMemory(
        buffer: *const ::std::os::raw::c_void,
        bufferSize: size_t,
        mode: FileMode,
        owner: bool,
        pOut: *mut FileStream,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks if stream is a standard system stream"]
    pub fn fsIsSystemFileStream(pStream: *mut FileStream) -> bool;
}
extern "C" {
    #[doc = " Checks if stream is a memory stream"]
    pub fn fsIsMemoryStream(pStream: *mut FileStream) -> bool;
}
extern "C" {
    #[doc = " Closes and invalidates the file stream."]
    pub fn fsCloseStream(stream: *mut FileStream) -> bool;
}
extern "C" {
    #[doc = " Returns the number of bytes read."]
    pub fn fsReadFromStream(
        stream: *mut FileStream,
        outputBuffer: *mut ::std::os::raw::c_void,
        bufferSizeInBytes: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Reads at most `bufferSizeInBytes` bytes from sourceBuffer and writes them into the file."]
    #[doc = " Returns the number of bytes written."]
    pub fn fsWriteToStream(
        stream: *mut FileStream,
        sourceBuffer: *const ::std::os::raw::c_void,
        byteCount: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Writes `byteCount` bytes from one stream to another"]
    pub fn fsCopyStream(pDst: *mut FileStream, pSrc: *mut FileStream, byteCount: size_t) -> bool;
}
extern "C" {
    #[doc = " Seeks to the specified position in the file, using `baseOffset` as the reference offset."]
    pub fn fsSeekStream(pStream: *mut FileStream, baseOffset: SeekBaseOffset, seekOffset: ssize_t) -> bool;
}
extern "C" {
    pub fn fsFindStream(
        pStream: *mut FileStream,
        pFind: *const ::std::os::raw::c_void,
        findSize: size_t,
        maxSeek: ssize_t,
        pPosition: *mut ssize_t,
    ) -> bool;
}
extern "C" {
    pub fn fsFindReverseStream(
        pStream: *mut FileStream,
        pFind: *const ::std::os::raw::c_void,
        findSize: size_t,
        maxSeek: ssize_t,
        pPosition: *mut ssize_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current seek position in the file."]
    pub fn fsGetStreamSeekPosition(stream: *const FileStream) -> ssize_t;
}
extern "C" {
    #[doc = " Gets the current size of the file. Returns -1 if the size is unknown or unavailable."]
    pub fn fsGetStreamFileSize(stream: *const FileStream) -> ssize_t;
}
extern "C" {
    #[doc = " Flushes all writes to the file stream to the underlying subsystem."]
    pub fn fsFlushStream(stream: *mut FileStream) -> bool;
}
extern "C" {
    #[doc = " Returns whether the current seek position is at the end of the file stream."]
    pub fn fsStreamAtEnd(stream: *const FileStream) -> bool;
}
extern "C" {
    #[doc = " Get property of a stream (minizip requires such function)"]
    pub fn fsGetStreamPropInt64(pStream: *mut FileStream, prop: i32, pValue: *mut i64) -> bool;
}
extern "C" {
    #[doc = " Set property of a stream (minizip requires such function)"]
    pub fn fsSetStreamPropInt64(pStream: *mut FileStream, prop: i32, value: i64) -> bool;
}
extern "C" {
    #[doc = " Gets buffer pointer from the begining of memory stream"]
    pub fn fsGetMemoryStreamBuffer(pStream: *mut FileStream, pBuf: *mut *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Gets buffer pointer from the begining of memory stream with a given offset"]
    pub fn fsGetMemoryStreamBufferAt(
        pStream: *mut FileStream,
        offset: ssize_t,
        pBuf: *mut *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn fsAppendPathComponent(
        basePath: *const ::std::os::raw::c_char,
        pathComponent: *const ::std::os::raw::c_char,
        output: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Appends `newExtension` to `basePath`."]
    #[doc = " If `basePath` already has an extension, `newExtension` will be appended to the end."]
    pub fn fsAppendPathExtension(
        basePath: *const ::std::os::raw::c_char,
        newExtension: *const ::std::os::raw::c_char,
        output: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Appends `newExtension` to `basePath`."]
    #[doc = " If `basePath` already has an extension, its previous extension will be replaced by `newExtension`."]
    pub fn fsReplacePathExtension(
        path: *const ::std::os::raw::c_char,
        newExtension: *const ::std::os::raw::c_char,
        output: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get `path`'s parent path, excluding the end seperator."]
    pub fn fsGetParentPath(path: *const ::std::os::raw::c_char, output: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get `path`'s file name, without extension or parent path."]
    pub fn fsGetPathFileName(path: *const ::std::os::raw::c_char, output: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns `path`'s extension, excluding the '.'."]
    pub fn fsGetPathExtension(path: *const ::std::os::raw::c_char, output: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn fsGetResourceDirectory(resourceDir: ResourceDirectory) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns Resource Mount point for resource directory"]
    pub fn fsGetResourceDirectoryMount(resourceDir: ResourceDirectory) -> ResourceMount;
}
extern "C" {
    #[doc = " Sets the relative path for `resourceDir` from `mount` to `bundledFolder`."]
    #[doc = " The `resourceDir` will making use of the given IFileSystem `pIO` file functions."]
    #[doc = " When `mount` is set to `RM_CONTENT` for a `resourceDir`, this directory is marked as a bundled resource folder."]
    #[doc = " Bundled resource folders should only be used for Read operations."]
    #[doc = " NOTE: A `resourceDir` can only be set once."]
    pub fn fsSetPathForResourceDir(
        pIO: *mut IFileSystem,
        mount: ResourceMount,
        resourceDir: ResourceDirectory,
        bundledFolder: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn getUSec() -> i64;
}
extern "C" {
    pub fn getTimerFrequency() -> i64;
}
extern "C" {
    pub fn getSystemTime() -> u32;
}
extern "C" {
    pub fn getTimeSinceStart() -> u32;
}
#[doc = " Low res OS timer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Timer {
    pub mStartTime: u32,
}
#[test]
fn bindgen_test_layout_Timer() {
    assert_eq!(
        ::std::mem::size_of::<Timer>(),
        4usize,
        concat!("Size of: ", stringify!(Timer))
    );
    assert_eq!(
        ::std::mem::align_of::<Timer>(),
        4usize,
        concat!("Alignment of ", stringify!(Timer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Timer>())).mStartTime as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Timer), "::", stringify!(mStartTime))
    );
}
extern "C" {
    pub fn initTimer(pTimer: *mut Timer);
}
extern "C" {
    pub fn resetTimer(pTimer: *mut Timer);
}
extern "C" {
    pub fn getTimerMSec(pTimer: *mut Timer, reset: bool) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HiresTimer {
    pub mStartTime: i64,
    pub mHistory: [i64; 60usize],
    pub mHistoryIndex: u32,
}
#[test]
fn bindgen_test_layout_HiresTimer() {
    assert_eq!(
        ::std::mem::size_of::<HiresTimer>(),
        496usize,
        concat!("Size of: ", stringify!(HiresTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<HiresTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(HiresTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HiresTimer>())).mStartTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HiresTimer),
            "::",
            stringify!(mStartTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HiresTimer>())).mHistory as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(HiresTimer), "::", stringify!(mHistory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HiresTimer>())).mHistoryIndex as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(HiresTimer),
            "::",
            stringify!(mHistoryIndex)
        )
    );
}
extern "C" {
    pub fn initHiresTimer(pTimer: *mut HiresTimer);
}
extern "C" {
    pub fn getHiresTimerUSec(pTimer: *mut HiresTimer, reset: bool) -> i64;
}
extern "C" {
    pub fn getHiresTimerUSecAverage(pTimer: *mut HiresTimer) -> i64;
}
extern "C" {
    pub fn getHiresTimerSeconds(pTimer: *mut HiresTimer, reset: bool) -> f32;
}
extern "C" {
    pub fn getHiresTimerSecondsAverage(pTimer: *mut HiresTimer) -> f32;
}
extern "C" {
    pub fn resetHiresTimer(pTimer: *mut HiresTimer);
}
