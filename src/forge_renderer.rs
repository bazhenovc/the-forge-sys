/* automatically generated by rust-bindgen 0.59.1 */

use crate::forge_os::WindowHandle;
use crate::tiny_image_format::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct D3D12MA_Allocator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct D3D12MA_Allocation {
    _unused: [u8; 0],
}
pub const MAX_INSTANCE_EXTENSIONS: ::std::os::raw::c_int = 64;
pub const MAX_DEVICE_EXTENSIONS: ::std::os::raw::c_int = 64;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_LINKED_GPUS: ::std::os::raw::c_int = 4;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_RENDER_TARGET_ATTACHMENTS: ::std::os::raw::c_int = 8;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_VERTEX_BINDINGS: ::std::os::raw::c_int = 15;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_VERTEX_ATTRIBS: ::std::os::raw::c_int = 15;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_SEMANTIC_NAME_LENGTH: ::std::os::raw::c_int = 128;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_DEBUG_NAME_LENGTH: ::std::os::raw::c_int = 128;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_MIP_LEVELS: ::std::os::raw::c_int = -1;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_SWAPCHAIN_IMAGES: ::std::os::raw::c_int = 3;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_ROOT_CONSTANTS_PER_ROOTSIGNATURE: ::std::os::raw::c_int = 4;
#[doc = " Max number of GPUs in SLI or Cross-Fire"]
pub const MAX_GPU_VENDOR_STRING_LENGTH: ::std::os::raw::c_int = 64;
pub const MAX_PLANE_COUNT: ::std::os::raw::c_int = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const RendererApi_RENDERER_API_D3D12: RendererApi = 0;
pub const RendererApi_RENDERER_API_VULKAN: RendererApi = 1;
pub const RendererApi_RENDERER_API_COUNT: RendererApi = 2;
pub type RendererApi = ::std::os::raw::c_int;
pub const QueueType_QUEUE_TYPE_GRAPHICS: QueueType = 0;
pub const QueueType_QUEUE_TYPE_TRANSFER: QueueType = 1;
pub const QueueType_QUEUE_TYPE_COMPUTE: QueueType = 2;
pub const QueueType_MAX_QUEUE_TYPE: QueueType = 3;
pub type QueueType = ::std::os::raw::c_int;
pub const QueueFlag_QUEUE_FLAG_NONE: QueueFlag = 0;
pub const QueueFlag_QUEUE_FLAG_DISABLE_GPU_TIMEOUT: QueueFlag = 1;
pub const QueueFlag_QUEUE_FLAG_INIT_MICROPROFILE: QueueFlag = 2;
pub const QueueFlag_MAX_QUEUE_FLAG: QueueFlag = -1;
pub type QueueFlag = ::std::os::raw::c_int;
pub const QueuePriority_QUEUE_PRIORITY_NORMAL: QueuePriority = 0;
pub const QueuePriority_QUEUE_PRIORITY_HIGH: QueuePriority = 1;
pub const QueuePriority_QUEUE_PRIORITY_GLOBAL_REALTIME: QueuePriority = 2;
pub const QueuePriority_MAX_QUEUE_PRIORITY: QueuePriority = 3;
pub type QueuePriority = ::std::os::raw::c_int;
pub const LoadActionType_LOAD_ACTION_DONTCARE: LoadActionType = 0;
pub const LoadActionType_LOAD_ACTION_LOAD: LoadActionType = 1;
pub const LoadActionType_LOAD_ACTION_CLEAR: LoadActionType = 2;
pub const LoadActionType_MAX_LOAD_ACTION: LoadActionType = 3;
pub type LoadActionType = ::std::os::raw::c_int;
pub const LogLevel_eNONE: LogLevel = 0;
pub const LogLevel_eRAW: LogLevel = 1;
pub const LogLevel_eDEBUG: LogLevel = 2;
pub const LogLevel_eINFO: LogLevel = 4;
pub const LogLevel_eWARNING: LogLevel = 8;
pub const LogLevel_eERROR: LogLevel = 16;
pub const LogLevel_eALL: LogLevel = -1;
pub type LogLevel = ::std::os::raw::c_int;
pub type LogFn = ::std::option::Option<
    unsafe extern "C" fn(arg1: LogLevel, arg2: *const ::std::os::raw::c_char, arg3: *const ::std::os::raw::c_char),
>;
pub const ResourceState_RESOURCE_STATE_UNDEFINED: ResourceState = 0;
pub const ResourceState_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER: ResourceState = 1;
pub const ResourceState_RESOURCE_STATE_INDEX_BUFFER: ResourceState = 2;
pub const ResourceState_RESOURCE_STATE_RENDER_TARGET: ResourceState = 4;
pub const ResourceState_RESOURCE_STATE_UNORDERED_ACCESS: ResourceState = 8;
pub const ResourceState_RESOURCE_STATE_DEPTH_WRITE: ResourceState = 16;
pub const ResourceState_RESOURCE_STATE_DEPTH_READ: ResourceState = 32;
pub const ResourceState_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE: ResourceState = 64;
pub const ResourceState_RESOURCE_STATE_PIXEL_SHADER_RESOURCE: ResourceState = 128;
pub const ResourceState_RESOURCE_STATE_SHADER_RESOURCE: ResourceState = 192;
pub const ResourceState_RESOURCE_STATE_STREAM_OUT: ResourceState = 256;
pub const ResourceState_RESOURCE_STATE_INDIRECT_ARGUMENT: ResourceState = 512;
pub const ResourceState_RESOURCE_STATE_COPY_DEST: ResourceState = 1024;
pub const ResourceState_RESOURCE_STATE_COPY_SOURCE: ResourceState = 2048;
pub const ResourceState_RESOURCE_STATE_GENERIC_READ: ResourceState = 2755;
pub const ResourceState_RESOURCE_STATE_PRESENT: ResourceState = 4096;
pub const ResourceState_RESOURCE_STATE_COMMON: ResourceState = 8192;
pub const ResourceState_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE: ResourceState = 16384;
pub const ResourceState_RESOURCE_STATE_SHADING_RATE_SOURCE: ResourceState = 32768;
pub type ResourceState = ::std::os::raw::c_int;
#[doc = " No intended memory usage specified."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_UNKNOWN: ResourceMemoryUsage = 0;
#[doc = " Memory will be used on device only, no need to be mapped on host."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_GPU_ONLY: ResourceMemoryUsage = 1;
#[doc = " Memory will be mapped on host. Could be used for transfer to device."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_CPU_ONLY: ResourceMemoryUsage = 2;
#[doc = " Memory will be used for frequent (dynamic) updates from host and reads on device."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_CPU_TO_GPU: ResourceMemoryUsage = 3;
#[doc = " Memory will be used for writing on device and readback on host."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_GPU_TO_CPU: ResourceMemoryUsage = 4;
#[doc = " Memory will be used for writing on device and readback on host."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_COUNT: ResourceMemoryUsage = 5;
#[doc = " Memory will be used for writing on device and readback on host."]
pub const ResourceMemoryUsage_RESOURCE_MEMORY_USAGE_MAX_ENUM: ResourceMemoryUsage = 2147483647;
#[doc = " Choosing Memory Type"]
pub type ResourceMemoryUsage = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Renderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pipeline {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderTarget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorIndexMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Raytracing {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RaytracingHitGroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelerationStructure {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsramManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectDrawArguments {
    pub mVertexCount: u32,
    pub mInstanceCount: u32,
    pub mStartVertex: u32,
    pub mStartInstance: u32,
}
#[test]
fn bindgen_test_layout_IndirectDrawArguments() {
    assert_eq!(
        ::std::mem::size_of::<IndirectDrawArguments>(),
        16usize,
        concat!("Size of: ", stringify!(IndirectDrawArguments))
    );
    assert_eq!(
        ::std::mem::align_of::<IndirectDrawArguments>(),
        4usize,
        concat!("Alignment of ", stringify!(IndirectDrawArguments))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawArguments>())).mVertexCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawArguments),
            "::",
            stringify!(mVertexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawArguments>())).mInstanceCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawArguments),
            "::",
            stringify!(mInstanceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawArguments>())).mStartVertex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawArguments),
            "::",
            stringify!(mStartVertex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawArguments>())).mStartInstance as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawArguments),
            "::",
            stringify!(mStartInstance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectDrawIndexArguments {
    pub mIndexCount: u32,
    pub mInstanceCount: u32,
    pub mStartIndex: u32,
    pub mVertexOffset: u32,
    pub mStartInstance: u32,
}
#[test]
fn bindgen_test_layout_IndirectDrawIndexArguments() {
    assert_eq!(
        ::std::mem::size_of::<IndirectDrawIndexArguments>(),
        20usize,
        concat!("Size of: ", stringify!(IndirectDrawIndexArguments))
    );
    assert_eq!(
        ::std::mem::align_of::<IndirectDrawIndexArguments>(),
        4usize,
        concat!("Alignment of ", stringify!(IndirectDrawIndexArguments))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawIndexArguments>())).mIndexCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawIndexArguments),
            "::",
            stringify!(mIndexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawIndexArguments>())).mInstanceCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawIndexArguments),
            "::",
            stringify!(mInstanceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawIndexArguments>())).mStartIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawIndexArguments),
            "::",
            stringify!(mStartIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawIndexArguments>())).mVertexOffset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawIndexArguments),
            "::",
            stringify!(mVertexOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDrawIndexArguments>())).mStartInstance as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDrawIndexArguments),
            "::",
            stringify!(mStartInstance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectDispatchArguments {
    pub mGroupCountX: u32,
    pub mGroupCountY: u32,
    pub mGroupCountZ: u32,
}
#[test]
fn bindgen_test_layout_IndirectDispatchArguments() {
    assert_eq!(
        ::std::mem::size_of::<IndirectDispatchArguments>(),
        12usize,
        concat!("Size of: ", stringify!(IndirectDispatchArguments))
    );
    assert_eq!(
        ::std::mem::align_of::<IndirectDispatchArguments>(),
        4usize,
        concat!("Alignment of ", stringify!(IndirectDispatchArguments))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDispatchArguments>())).mGroupCountX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDispatchArguments),
            "::",
            stringify!(mGroupCountX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDispatchArguments>())).mGroupCountY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDispatchArguments),
            "::",
            stringify!(mGroupCountY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectDispatchArguments>())).mGroupCountZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectDispatchArguments),
            "::",
            stringify!(mGroupCountZ)
        )
    );
}
pub const IndirectArgumentType_INDIRECT_DRAW: IndirectArgumentType = 0;
pub const IndirectArgumentType_INDIRECT_DRAW_INDEX: IndirectArgumentType = 1;
pub const IndirectArgumentType_INDIRECT_DISPATCH: IndirectArgumentType = 2;
pub const IndirectArgumentType_INDIRECT_VERTEX_BUFFER: IndirectArgumentType = 3;
pub const IndirectArgumentType_INDIRECT_INDEX_BUFFER: IndirectArgumentType = 4;
pub const IndirectArgumentType_INDIRECT_CONSTANT: IndirectArgumentType = 5;
pub const IndirectArgumentType_INDIRECT_DESCRIPTOR_TABLE: IndirectArgumentType = 6;
pub const IndirectArgumentType_INDIRECT_PIPELINE: IndirectArgumentType = 7;
pub const IndirectArgumentType_INDIRECT_CONSTANT_BUFFER_VIEW: IndirectArgumentType = 8;
pub const IndirectArgumentType_INDIRECT_SHADER_RESOURCE_VIEW: IndirectArgumentType = 9;
pub const IndirectArgumentType_INDIRECT_UNORDERED_ACCESS_VIEW: IndirectArgumentType = 10;
pub type IndirectArgumentType = ::std::os::raw::c_int;
pub const DescriptorType_DESCRIPTOR_TYPE_UNDEFINED: DescriptorType = 0;
pub const DescriptorType_DESCRIPTOR_TYPE_SAMPLER: DescriptorType = 1;
pub const DescriptorType_DESCRIPTOR_TYPE_TEXTURE: DescriptorType = 2;
#[doc = " UAV Texture"]
pub const DescriptorType_DESCRIPTOR_TYPE_RW_TEXTURE: DescriptorType = 4;
#[doc = " UAV Texture"]
pub const DescriptorType_DESCRIPTOR_TYPE_BUFFER: DescriptorType = 8;
#[doc = " UAV Texture"]
pub const DescriptorType_DESCRIPTOR_TYPE_BUFFER_RAW: DescriptorType = 24;
#[doc = " UAV Buffer"]
pub const DescriptorType_DESCRIPTOR_TYPE_RW_BUFFER: DescriptorType = 32;
#[doc = " UAV Buffer"]
pub const DescriptorType_DESCRIPTOR_TYPE_RW_BUFFER_RAW: DescriptorType = 96;
#[doc = " Uniform buffer"]
pub const DescriptorType_DESCRIPTOR_TYPE_UNIFORM_BUFFER: DescriptorType = 128;
#[doc = " Push constant / Root constant"]
pub const DescriptorType_DESCRIPTOR_TYPE_ROOT_CONSTANT: DescriptorType = 256;
#[doc = " IA"]
pub const DescriptorType_DESCRIPTOR_TYPE_VERTEX_BUFFER: DescriptorType = 512;
#[doc = " IA"]
pub const DescriptorType_DESCRIPTOR_TYPE_INDEX_BUFFER: DescriptorType = 1024;
#[doc = " IA"]
pub const DescriptorType_DESCRIPTOR_TYPE_INDIRECT_BUFFER: DescriptorType = 2048;
#[doc = " Cubemap SRV"]
pub const DescriptorType_DESCRIPTOR_TYPE_TEXTURE_CUBE: DescriptorType = 4098;
#[doc = " RTV / DSV per mip slice"]
pub const DescriptorType_DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES: DescriptorType = 8192;
#[doc = " RTV / DSV per array slice"]
pub const DescriptorType_DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES: DescriptorType = 16384;
#[doc = " RTV / DSV per depth slice"]
pub const DescriptorType_DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES: DescriptorType = 32768;
#[doc = " RTV / DSV per depth slice"]
pub const DescriptorType_DESCRIPTOR_TYPE_RAY_TRACING: DescriptorType = 65536;
#[doc = " Subpass input (descriptor type only available in Vulkan)"]
pub const DescriptorType_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: DescriptorType = 131072;
#[doc = " Subpass input (descriptor type only available in Vulkan)"]
pub const DescriptorType_DESCRIPTOR_TYPE_TEXEL_BUFFER: DescriptorType = 262144;
#[doc = " Subpass input (descriptor type only available in Vulkan)"]
pub const DescriptorType_DESCRIPTOR_TYPE_RW_TEXEL_BUFFER: DescriptorType = 524288;
#[doc = " Subpass input (descriptor type only available in Vulkan)"]
pub const DescriptorType_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: DescriptorType = 1048576;
pub type DescriptorType = ::std::os::raw::c_int;
pub const SampleCount_SAMPLE_COUNT_1: SampleCount = 1;
pub const SampleCount_SAMPLE_COUNT_2: SampleCount = 2;
pub const SampleCount_SAMPLE_COUNT_4: SampleCount = 4;
pub const SampleCount_SAMPLE_COUNT_8: SampleCount = 8;
pub const SampleCount_SAMPLE_COUNT_16: SampleCount = 16;
pub type SampleCount = ::std::os::raw::c_int;
pub const ShaderStage_SHADER_STAGE_NONE: ShaderStage = 0;
pub const ShaderStage_SHADER_STAGE_VERT: ShaderStage = 1;
pub const ShaderStage_SHADER_STAGE_TESC: ShaderStage = 2;
pub const ShaderStage_SHADER_STAGE_TESE: ShaderStage = 4;
pub const ShaderStage_SHADER_STAGE_GEOM: ShaderStage = 8;
pub const ShaderStage_SHADER_STAGE_FRAG: ShaderStage = 16;
pub const ShaderStage_SHADER_STAGE_COMP: ShaderStage = 32;
pub const ShaderStage_SHADER_STAGE_RAYTRACING: ShaderStage = 64;
pub const ShaderStage_SHADER_STAGE_ALL_GRAPHICS: ShaderStage = 31;
pub const ShaderStage_SHADER_STAGE_HULL: ShaderStage = 2;
pub const ShaderStage_SHADER_STAGE_DOMN: ShaderStage = 4;
pub const ShaderStage_SHADER_STAGE_COUNT: ShaderStage = 7;
pub type ShaderStage = ::std::os::raw::c_int;
pub const MAX_SHADER_STAGE_COUNT: u32 = 5;
pub const TextureDimension_TEXTURE_DIM_1D: TextureDimension = 0;
pub const TextureDimension_TEXTURE_DIM_2D: TextureDimension = 1;
pub const TextureDimension_TEXTURE_DIM_2DMS: TextureDimension = 2;
pub const TextureDimension_TEXTURE_DIM_3D: TextureDimension = 3;
pub const TextureDimension_TEXTURE_DIM_CUBE: TextureDimension = 4;
pub const TextureDimension_TEXTURE_DIM_1D_ARRAY: TextureDimension = 5;
pub const TextureDimension_TEXTURE_DIM_2D_ARRAY: TextureDimension = 6;
pub const TextureDimension_TEXTURE_DIM_2DMS_ARRAY: TextureDimension = 7;
pub const TextureDimension_TEXTURE_DIM_CUBE_ARRAY: TextureDimension = 8;
pub const TextureDimension_TEXTURE_DIM_COUNT: TextureDimension = 9;
pub const TextureDimension_TEXTURE_DIM_UNDEFINED: TextureDimension = 10;
pub type TextureDimension = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexInput {
    pub name: *const ::std::os::raw::c_char,
    pub size: u32,
    pub name_size: u32,
}
#[test]
fn bindgen_test_layout_VertexInput() {
    assert_eq!(
        ::std::mem::size_of::<VertexInput>(),
        16usize,
        concat!("Size of: ", stringify!(VertexInput))
    );
    assert_eq!(
        ::std::mem::align_of::<VertexInput>(),
        8usize,
        concat!("Alignment of ", stringify!(VertexInput))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexInput>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(VertexInput), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexInput>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(VertexInput), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexInput>())).name_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexInput),
            "::",
            stringify!(name_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderResource {
    pub type_: DescriptorType,
    pub set: u32,
    pub reg: u32,
    pub size: u32,
    pub used_stages: ShaderStage,
    pub name: *const ::std::os::raw::c_char,
    pub name_size: u32,
    pub dim: TextureDimension,
}
#[test]
fn bindgen_test_layout_ShaderResource() {
    assert_eq!(
        ::std::mem::size_of::<ShaderResource>(),
        40usize,
        concat!("Size of: ", stringify!(ShaderResource))
    );
    assert_eq!(
        ::std::mem::align_of::<ShaderResource>(),
        8usize,
        concat!("Alignment of ", stringify!(ShaderResource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ShaderResource), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).set as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ShaderResource), "::", stringify!(set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).reg as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ShaderResource), "::", stringify!(reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).size as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(ShaderResource), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).used_stages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderResource),
            "::",
            stringify!(used_stages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).name as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ShaderResource), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).name_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderResource),
            "::",
            stringify!(name_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderResource>())).dim as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(ShaderResource), "::", stringify!(dim))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderVariable {
    pub name: *const ::std::os::raw::c_char,
    pub parent_index: u32,
    pub offset: u32,
    pub size: u32,
    pub name_size: u32,
}
#[test]
fn bindgen_test_layout_ShaderVariable() {
    assert_eq!(
        ::std::mem::size_of::<ShaderVariable>(),
        24usize,
        concat!("Size of: ", stringify!(ShaderVariable))
    );
    assert_eq!(
        ::std::mem::align_of::<ShaderVariable>(),
        8usize,
        concat!("Alignment of ", stringify!(ShaderVariable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderVariable>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ShaderVariable), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderVariable>())).parent_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderVariable),
            "::",
            stringify!(parent_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderVariable>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderVariable),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderVariable>())).size as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ShaderVariable), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderVariable>())).name_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderVariable),
            "::",
            stringify!(name_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderReflection {
    pub pNamePool: *mut ::std::os::raw::c_char,
    pub pVertexInputs: *mut VertexInput,
    pub pShaderResources: *mut ShaderResource,
    pub pVariables: *mut ShaderVariable,
    pub pEntryPoint: *mut ::std::os::raw::c_char,
    pub mShaderStage: ShaderStage,
    pub mNamePoolSize: u32,
    pub mVertexInputsCount: u32,
    pub mShaderResourceCount: u32,
    pub mVariableCount: u32,
    pub mNumThreadsPerGroup: [u32; 3usize],
    pub mNumControlPoint: u32,
}
#[test]
fn bindgen_test_layout_ShaderReflection() {
    assert_eq!(
        ::std::mem::size_of::<ShaderReflection>(),
        80usize,
        concat!("Size of: ", stringify!(ShaderReflection))
    );
    assert_eq!(
        ::std::mem::align_of::<ShaderReflection>(),
        8usize,
        concat!("Alignment of ", stringify!(ShaderReflection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).pNamePool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(pNamePool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).pVertexInputs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(pVertexInputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).pShaderResources as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(pShaderResources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).pVariables as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(pVariables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).pEntryPoint as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(pEntryPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mShaderStage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mShaderStage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mNamePoolSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mNamePoolSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mVertexInputsCount as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mVertexInputsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mShaderResourceCount as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mShaderResourceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mVariableCount as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mVariableCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mNumThreadsPerGroup as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mNumThreadsPerGroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderReflection>())).mNumControlPoint as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderReflection),
            "::",
            stringify!(mNumControlPoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineReflection {
    pub mShaderStages: ShaderStage,
    pub mStageReflections: [ShaderReflection; 5usize],
    pub mStageReflectionCount: u32,
    pub mVertexStageIndex: u32,
    pub mHullStageIndex: u32,
    pub mDomainStageIndex: u32,
    pub mGeometryStageIndex: u32,
    pub mPixelStageIndex: u32,
    pub pShaderResources: *mut ShaderResource,
    pub mShaderResourceCount: u32,
    pub pVariables: *mut ShaderVariable,
    pub mVariableCount: u32,
}
#[test]
fn bindgen_test_layout_PipelineReflection() {
    assert_eq!(
        ::std::mem::size_of::<PipelineReflection>(),
        464usize,
        concat!("Size of: ", stringify!(PipelineReflection))
    );
    assert_eq!(
        ::std::mem::align_of::<PipelineReflection>(),
        8usize,
        concat!("Alignment of ", stringify!(PipelineReflection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mShaderStages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mShaderStages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mStageReflections as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mStageReflections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mStageReflectionCount as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mStageReflectionCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mVertexStageIndex as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mVertexStageIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mHullStageIndex as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mHullStageIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mDomainStageIndex as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mDomainStageIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mGeometryStageIndex as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mGeometryStageIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mPixelStageIndex as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mPixelStageIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).pShaderResources as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(pShaderResources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mShaderResourceCount as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mShaderResourceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).pVariables as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(pVariables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineReflection>())).mVariableCount as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineReflection),
            "::",
            stringify!(mVariableCount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?destroyShaderReflection@@YAXPEAUShaderReflection@@@Z"]
    pub fn destroyShaderReflection(pReflection: *mut ShaderReflection);
}
extern "C" {
    #[link_name = "\u{1}?createPipelineReflection@@YAXPEAUShaderReflection@@IPEAUPipelineReflection@@@Z"]
    pub fn createPipelineReflection(
        pReflection: *mut ShaderReflection,
        stageCount: u32,
        pOutReflection: *mut PipelineReflection,
    );
}
extern "C" {
    #[link_name = "\u{1}?destroyPipelineReflection@@YAXPEAUPipelineReflection@@@Z"]
    pub fn destroyPipelineReflection(pReflection: *mut PipelineReflection);
}
pub const PrimitiveTopology_PRIMITIVE_TOPO_POINT_LIST: PrimitiveTopology = 0;
pub const PrimitiveTopology_PRIMITIVE_TOPO_LINE_LIST: PrimitiveTopology = 1;
pub const PrimitiveTopology_PRIMITIVE_TOPO_LINE_STRIP: PrimitiveTopology = 2;
pub const PrimitiveTopology_PRIMITIVE_TOPO_TRI_LIST: PrimitiveTopology = 3;
pub const PrimitiveTopology_PRIMITIVE_TOPO_TRI_STRIP: PrimitiveTopology = 4;
pub const PrimitiveTopology_PRIMITIVE_TOPO_PATCH_LIST: PrimitiveTopology = 5;
pub const PrimitiveTopology_PRIMITIVE_TOPO_COUNT: PrimitiveTopology = 6;
pub type PrimitiveTopology = ::std::os::raw::c_int;
pub const IndexType_INDEX_TYPE_UINT32: IndexType = 0;
pub const IndexType_INDEX_TYPE_UINT16: IndexType = 1;
pub type IndexType = ::std::os::raw::c_int;
pub const ShaderSemantic_SEMANTIC_UNDEFINED: ShaderSemantic = 0;
pub const ShaderSemantic_SEMANTIC_POSITION: ShaderSemantic = 1;
pub const ShaderSemantic_SEMANTIC_NORMAL: ShaderSemantic = 2;
pub const ShaderSemantic_SEMANTIC_COLOR: ShaderSemantic = 3;
pub const ShaderSemantic_SEMANTIC_TANGENT: ShaderSemantic = 4;
pub const ShaderSemantic_SEMANTIC_BITANGENT: ShaderSemantic = 5;
pub const ShaderSemantic_SEMANTIC_JOINTS: ShaderSemantic = 6;
pub const ShaderSemantic_SEMANTIC_WEIGHTS: ShaderSemantic = 7;
pub const ShaderSemantic_SEMANTIC_SHADING_RATE: ShaderSemantic = 8;
pub const ShaderSemantic_SEMANTIC_TEXCOORD0: ShaderSemantic = 9;
pub const ShaderSemantic_SEMANTIC_TEXCOORD1: ShaderSemantic = 10;
pub const ShaderSemantic_SEMANTIC_TEXCOORD2: ShaderSemantic = 11;
pub const ShaderSemantic_SEMANTIC_TEXCOORD3: ShaderSemantic = 12;
pub const ShaderSemantic_SEMANTIC_TEXCOORD4: ShaderSemantic = 13;
pub const ShaderSemantic_SEMANTIC_TEXCOORD5: ShaderSemantic = 14;
pub const ShaderSemantic_SEMANTIC_TEXCOORD6: ShaderSemantic = 15;
pub const ShaderSemantic_SEMANTIC_TEXCOORD7: ShaderSemantic = 16;
pub const ShaderSemantic_SEMANTIC_TEXCOORD8: ShaderSemantic = 17;
pub const ShaderSemantic_SEMANTIC_TEXCOORD9: ShaderSemantic = 18;
pub type ShaderSemantic = ::std::os::raw::c_int;
pub const BlendConstant_BC_ZERO: BlendConstant = 0;
pub const BlendConstant_BC_ONE: BlendConstant = 1;
pub const BlendConstant_BC_SRC_COLOR: BlendConstant = 2;
pub const BlendConstant_BC_ONE_MINUS_SRC_COLOR: BlendConstant = 3;
pub const BlendConstant_BC_DST_COLOR: BlendConstant = 4;
pub const BlendConstant_BC_ONE_MINUS_DST_COLOR: BlendConstant = 5;
pub const BlendConstant_BC_SRC_ALPHA: BlendConstant = 6;
pub const BlendConstant_BC_ONE_MINUS_SRC_ALPHA: BlendConstant = 7;
pub const BlendConstant_BC_DST_ALPHA: BlendConstant = 8;
pub const BlendConstant_BC_ONE_MINUS_DST_ALPHA: BlendConstant = 9;
pub const BlendConstant_BC_SRC_ALPHA_SATURATE: BlendConstant = 10;
pub const BlendConstant_BC_BLEND_FACTOR: BlendConstant = 11;
pub const BlendConstant_BC_ONE_MINUS_BLEND_FACTOR: BlendConstant = 12;
pub const BlendConstant_MAX_BLEND_CONSTANTS: BlendConstant = 13;
pub type BlendConstant = ::std::os::raw::c_int;
pub const BlendMode_BM_ADD: BlendMode = 0;
pub const BlendMode_BM_SUBTRACT: BlendMode = 1;
pub const BlendMode_BM_REVERSE_SUBTRACT: BlendMode = 2;
pub const BlendMode_BM_MIN: BlendMode = 3;
pub const BlendMode_BM_MAX: BlendMode = 4;
pub const BlendMode_MAX_BLEND_MODES: BlendMode = 5;
pub type BlendMode = ::std::os::raw::c_int;
pub const CompareMode_CMP_NEVER: CompareMode = 0;
pub const CompareMode_CMP_LESS: CompareMode = 1;
pub const CompareMode_CMP_EQUAL: CompareMode = 2;
pub const CompareMode_CMP_LEQUAL: CompareMode = 3;
pub const CompareMode_CMP_GREATER: CompareMode = 4;
pub const CompareMode_CMP_NOTEQUAL: CompareMode = 5;
pub const CompareMode_CMP_GEQUAL: CompareMode = 6;
pub const CompareMode_CMP_ALWAYS: CompareMode = 7;
pub const CompareMode_MAX_COMPARE_MODES: CompareMode = 8;
pub type CompareMode = ::std::os::raw::c_int;
pub const StencilOp_STENCIL_OP_KEEP: StencilOp = 0;
pub const StencilOp_STENCIL_OP_SET_ZERO: StencilOp = 1;
pub const StencilOp_STENCIL_OP_REPLACE: StencilOp = 2;
pub const StencilOp_STENCIL_OP_INVERT: StencilOp = 3;
pub const StencilOp_STENCIL_OP_INCR: StencilOp = 4;
pub const StencilOp_STENCIL_OP_DECR: StencilOp = 5;
pub const StencilOp_STENCIL_OP_INCR_SAT: StencilOp = 6;
pub const StencilOp_STENCIL_OP_DECR_SAT: StencilOp = 7;
pub const StencilOp_MAX_STENCIL_OPS: StencilOp = 8;
pub type StencilOp = ::std::os::raw::c_int;
pub const RED: ::std::os::raw::c_int = 1;
pub const GREEN: ::std::os::raw::c_int = 2;
pub const BLUE: ::std::os::raw::c_int = 4;
pub const ALPHA: ::std::os::raw::c_int = 8;
pub const ALL: ::std::os::raw::c_int = 15;
pub const NONE: ::std::os::raw::c_int = 0;
pub const BS_NONE: ::std::os::raw::c_int = -1;
pub const DS_NONE: ::std::os::raw::c_int = -1;
pub const RS_NONE: ::std::os::raw::c_int = -1;
pub const BlendStateTargets_BLEND_STATE_TARGET_0: BlendStateTargets = 1;
pub const BlendStateTargets_BLEND_STATE_TARGET_1: BlendStateTargets = 2;
pub const BlendStateTargets_BLEND_STATE_TARGET_2: BlendStateTargets = 4;
pub const BlendStateTargets_BLEND_STATE_TARGET_3: BlendStateTargets = 8;
pub const BlendStateTargets_BLEND_STATE_TARGET_4: BlendStateTargets = 16;
pub const BlendStateTargets_BLEND_STATE_TARGET_5: BlendStateTargets = 32;
pub const BlendStateTargets_BLEND_STATE_TARGET_6: BlendStateTargets = 64;
pub const BlendStateTargets_BLEND_STATE_TARGET_7: BlendStateTargets = 128;
pub const BlendStateTargets_BLEND_STATE_TARGET_ALL: BlendStateTargets = 255;
pub type BlendStateTargets = ::std::os::raw::c_int;
pub const CullMode_CULL_MODE_NONE: CullMode = 0;
pub const CullMode_CULL_MODE_BACK: CullMode = 1;
pub const CullMode_CULL_MODE_FRONT: CullMode = 2;
pub const CullMode_CULL_MODE_BOTH: CullMode = 3;
pub const CullMode_MAX_CULL_MODES: CullMode = 4;
pub type CullMode = ::std::os::raw::c_int;
pub const FrontFace_FRONT_FACE_CCW: FrontFace = 0;
pub const FrontFace_FRONT_FACE_CW: FrontFace = 1;
pub type FrontFace = ::std::os::raw::c_int;
pub const FillMode_FILL_MODE_SOLID: FillMode = 0;
pub const FillMode_FILL_MODE_WIREFRAME: FillMode = 1;
pub const FillMode_MAX_FILL_MODES: FillMode = 2;
pub type FillMode = ::std::os::raw::c_int;
pub const PipelineType_PIPELINE_TYPE_UNDEFINED: PipelineType = 0;
pub const PipelineType_PIPELINE_TYPE_COMPUTE: PipelineType = 1;
pub const PipelineType_PIPELINE_TYPE_GRAPHICS: PipelineType = 2;
pub const PipelineType_PIPELINE_TYPE_RAYTRACING: PipelineType = 3;
pub const PipelineType_PIPELINE_TYPE_COUNT: PipelineType = 4;
pub type PipelineType = ::std::os::raw::c_int;
pub const FilterType_FILTER_NEAREST: FilterType = 0;
pub const FilterType_FILTER_LINEAR: FilterType = 1;
pub type FilterType = ::std::os::raw::c_int;
pub const AddressMode_ADDRESS_MODE_MIRROR: AddressMode = 0;
pub const AddressMode_ADDRESS_MODE_REPEAT: AddressMode = 1;
pub const AddressMode_ADDRESS_MODE_CLAMP_TO_EDGE: AddressMode = 2;
pub const AddressMode_ADDRESS_MODE_CLAMP_TO_BORDER: AddressMode = 3;
pub type AddressMode = ::std::os::raw::c_int;
pub const MipMapMode_MIPMAP_MODE_NEAREST: MipMapMode = 0;
pub const MipMapMode_MIPMAP_MODE_LINEAR: MipMapMode = 1;
pub type MipMapMode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearValue {
    pub __bindgen_anon_1: ClearValue__bindgen_ty_1,
    pub __bindgen_anon_2: ClearValue__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClearValue__bindgen_ty_1 {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_ClearValue__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ClearValue__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ClearValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ClearValue__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ClearValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClearValue__bindgen_ty_1>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClearValue__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClearValue__bindgen_ty_1>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClearValue__bindgen_ty_1),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClearValue__bindgen_ty_1>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClearValue__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClearValue__bindgen_ty_1>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClearValue__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClearValue__bindgen_ty_2 {
    pub depth: f32,
    pub stencil: u32,
}
#[test]
fn bindgen_test_layout_ClearValue__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ClearValue__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(ClearValue__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ClearValue__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(ClearValue__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClearValue__bindgen_ty_2>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClearValue__bindgen_ty_2),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClearValue__bindgen_ty_2>())).stencil as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClearValue__bindgen_ty_2),
            "::",
            stringify!(stencil)
        )
    );
}
#[test]
fn bindgen_test_layout_ClearValue() {
    assert_eq!(
        ::std::mem::size_of::<ClearValue>(),
        16usize,
        concat!("Size of: ", stringify!(ClearValue))
    );
    assert_eq!(
        ::std::mem::align_of::<ClearValue>(),
        4usize,
        concat!("Alignment of ", stringify!(ClearValue))
    );
}
pub const ShadingRate_SHADING_RATE_NOT_SUPPORTED: ShadingRate = 0;
pub const ShadingRate_SHADING_RATE_FULL: ShadingRate = 1;
pub const ShadingRate_SHADING_RATE_HALF: ShadingRate = 2;
pub const ShadingRate_SHADING_RATE_QUARTER: ShadingRate = 4;
pub const ShadingRate_SHADING_RATE_EIGHTH: ShadingRate = 8;
pub const ShadingRate_SHADING_RATE_1X2: ShadingRate = 16;
pub const ShadingRate_SHADING_RATE_2X1: ShadingRate = 32;
pub const ShadingRate_SHADING_RATE_2X4: ShadingRate = 64;
pub const ShadingRate_SHADING_RATE_4X2: ShadingRate = 128;
pub type ShadingRate = ::std::os::raw::c_int;
pub const ShadingRateCombiner_SHADING_RATE_COMBINER_PASSTHROUGH: ShadingRateCombiner = 0;
pub const ShadingRateCombiner_SHADING_RATE_COMBINER_OVERRIDE: ShadingRateCombiner = 1;
pub const ShadingRateCombiner_SHADING_RATE_COMBINER_MIN: ShadingRateCombiner = 2;
pub const ShadingRateCombiner_SHADING_RATE_COMBINER_MAX: ShadingRateCombiner = 3;
pub const ShadingRateCombiner_SHADING_RATE_COMBINER_SUM: ShadingRateCombiner = 4;
pub type ShadingRateCombiner = ::std::os::raw::c_int;
pub const ShadingRateCaps_SHADING_RATE_CAPS_NOT_SUPPORTED: ShadingRateCaps = 0;
pub const ShadingRateCaps_SHADING_RATE_CAPS_PER_DRAW: ShadingRateCaps = 1;
pub const ShadingRateCaps_SHADING_RATE_CAPS_PER_TILE: ShadingRateCaps = 2;
pub type ShadingRateCaps = ::std::os::raw::c_int;
#[doc = " Default flag (Buffer will use aliased memory, buffer will not be cpu accessible until mapBuffer is called)"]
pub const BufferCreationFlags_BUFFER_CREATION_FLAG_NONE: BufferCreationFlags = 1;
#[doc = " Buffer will allocate its own memory (COMMITTED resource)"]
pub const BufferCreationFlags_BUFFER_CREATION_FLAG_OWN_MEMORY_BIT: BufferCreationFlags = 2;
#[doc = " Buffer will be persistently mapped"]
pub const BufferCreationFlags_BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT: BufferCreationFlags = 4;
#[doc = " Use ESRAM to store this buffer"]
pub const BufferCreationFlags_BUFFER_CREATION_FLAG_ESRAM: BufferCreationFlags = 8;
#[doc = " Flag to specify not to allocate descriptors for the resource"]
pub const BufferCreationFlags_BUFFER_CREATION_FLAG_NO_DESCRIPTOR_VIEW_CREATION: BufferCreationFlags = 16;
pub type BufferCreationFlags = ::std::os::raw::c_int;
#[doc = " Default flag (Texture will use default allocation strategy decided by the api specific allocator)"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_NONE: TextureCreationFlags = 0;
#[doc = " Texture will allocate its own memory (COMMITTED resource)"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_OWN_MEMORY_BIT: TextureCreationFlags = 1;
#[doc = " Texture will be allocated in memory which can be shared among multiple processes"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_EXPORT_BIT: TextureCreationFlags = 2;
#[doc = " Texture will be allocated in memory which can be shared among multiple gpus"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_EXPORT_ADAPTER_BIT: TextureCreationFlags = 4;
#[doc = " Texture will be imported from a handle created in another process"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_IMPORT_BIT: TextureCreationFlags = 8;
#[doc = " Use ESRAM to store this texture"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_ESRAM: TextureCreationFlags = 16;
#[doc = " Use on-tile memory to store this texture"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_ON_TILE: TextureCreationFlags = 32;
#[doc = " Prevent compression meta data from generating (XBox)"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_NO_COMPRESSION: TextureCreationFlags = 64;
#[doc = " Force 2D instead of automatically determining dimension based on width, height, depth"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_FORCE_2D: TextureCreationFlags = 128;
#[doc = " Force 3D instead of automatically determining dimension based on width, height, depth"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_FORCE_3D: TextureCreationFlags = 256;
#[doc = " Display target"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_ALLOW_DISPLAY_TARGET: TextureCreationFlags = 512;
#[doc = " Create an sRGB texture."]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_SRGB: TextureCreationFlags = 1024;
#[doc = " Fast clear"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_FAST_CLEAR: TextureCreationFlags = 2048;
#[doc = " Fragment mask"]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_FRAG_MASK: TextureCreationFlags = 4096;
#[doc = " Doubles the amount of array layers of the texture when rendering VR. Also forces the texture to be a 2D Array texture."]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_VR_MULTIVIEW: TextureCreationFlags = 8192;
#[doc = " Binds the FFR fragment density if this texture is used as a render target."]
pub const TextureCreationFlags_TEXTURE_CREATION_FLAG_VR_FOVEATED_RENDERING: TextureCreationFlags = 16384;
pub type TextureCreationFlags = ::std::os::raw::c_int;
pub const GPUPresetLevel_GPU_PRESET_NONE: GPUPresetLevel = 0;
pub const GPUPresetLevel_GPU_PRESET_OFFICE: GPUPresetLevel = 1;
pub const GPUPresetLevel_GPU_PRESET_LOW: GPUPresetLevel = 2;
pub const GPUPresetLevel_GPU_PRESET_MEDIUM: GPUPresetLevel = 3;
pub const GPUPresetLevel_GPU_PRESET_HIGH: GPUPresetLevel = 4;
pub const GPUPresetLevel_GPU_PRESET_ULTRA: GPUPresetLevel = 5;
pub const GPUPresetLevel_GPU_PRESET_COUNT: GPUPresetLevel = 6;
pub type GPUPresetLevel = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferBarrier {
    pub pBuffer: *mut Buffer,
    pub mCurrentState: ResourceState,
    pub mNewState: ResourceState,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_BufferBarrier() {
    assert_eq!(
        ::std::mem::size_of::<BufferBarrier>(),
        24usize,
        concat!("Size of: ", stringify!(BufferBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<BufferBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(BufferBarrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferBarrier>())).pBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferBarrier),
            "::",
            stringify!(pBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferBarrier>())).mCurrentState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferBarrier),
            "::",
            stringify!(mCurrentState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferBarrier>())).mNewState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferBarrier),
            "::",
            stringify!(mNewState)
        )
    );
}
impl BufferBarrier {
    #[inline]
    pub fn mBeginOnly(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mBeginOnly(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mEndOnly(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mEndOnly(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAcquire(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAcquire(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRelease(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRelease(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mQueueType(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_mQueueType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mBeginOnly: u8,
        mEndOnly: u8,
        mAcquire: u8,
        mRelease: u8,
        mQueueType: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mBeginOnly: u8 = unsafe { ::std::mem::transmute(mBeginOnly) };
            mBeginOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mEndOnly: u8 = unsafe { ::std::mem::transmute(mEndOnly) };
            mEndOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mAcquire: u8 = unsafe { ::std::mem::transmute(mAcquire) };
            mAcquire as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRelease: u8 = unsafe { ::std::mem::transmute(mRelease) };
            mRelease as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let mQueueType: u8 = unsafe { ::std::mem::transmute(mQueueType) };
            mQueueType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextureBarrier {
    pub pTexture: *mut Texture,
    pub mCurrentState: ResourceState,
    pub mNewState: ResourceState,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mArrayLayer: u16,
}
#[test]
fn bindgen_test_layout_TextureBarrier() {
    assert_eq!(
        ::std::mem::size_of::<TextureBarrier>(),
        24usize,
        concat!("Size of: ", stringify!(TextureBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<TextureBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(TextureBarrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureBarrier>())).pTexture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureBarrier),
            "::",
            stringify!(pTexture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureBarrier>())).mCurrentState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureBarrier),
            "::",
            stringify!(mCurrentState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureBarrier>())).mNewState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureBarrier),
            "::",
            stringify!(mNewState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureBarrier>())).mArrayLayer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureBarrier),
            "::",
            stringify!(mArrayLayer)
        )
    );
}
impl TextureBarrier {
    #[inline]
    pub fn mBeginOnly(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mBeginOnly(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mEndOnly(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mEndOnly(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAcquire(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAcquire(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRelease(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRelease(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mQueueType(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_mQueueType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mSubresourceBarrier(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSubresourceBarrier(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMipLevel(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_mMipLevel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mBeginOnly: u8,
        mEndOnly: u8,
        mAcquire: u8,
        mRelease: u8,
        mQueueType: u8,
        mSubresourceBarrier: u8,
        mMipLevel: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mBeginOnly: u8 = unsafe { ::std::mem::transmute(mBeginOnly) };
            mBeginOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mEndOnly: u8 = unsafe { ::std::mem::transmute(mEndOnly) };
            mEndOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mAcquire: u8 = unsafe { ::std::mem::transmute(mAcquire) };
            mAcquire as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRelease: u8 = unsafe { ::std::mem::transmute(mRelease) };
            mRelease as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let mQueueType: u8 = unsafe { ::std::mem::transmute(mQueueType) };
            mQueueType as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let mSubresourceBarrier: u8 = unsafe { ::std::mem::transmute(mSubresourceBarrier) };
            mSubresourceBarrier as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let mMipLevel: u8 = unsafe { ::std::mem::transmute(mMipLevel) };
            mMipLevel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderTargetBarrier {
    pub pRenderTarget: *mut RenderTarget,
    pub mCurrentState: ResourceState,
    pub mNewState: ResourceState,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mArrayLayer: u16,
}
#[test]
fn bindgen_test_layout_RenderTargetBarrier() {
    assert_eq!(
        ::std::mem::size_of::<RenderTargetBarrier>(),
        24usize,
        concat!("Size of: ", stringify!(RenderTargetBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<RenderTargetBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(RenderTargetBarrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetBarrier>())).pRenderTarget as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetBarrier),
            "::",
            stringify!(pRenderTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetBarrier>())).mCurrentState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetBarrier),
            "::",
            stringify!(mCurrentState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetBarrier>())).mNewState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetBarrier),
            "::",
            stringify!(mNewState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetBarrier>())).mArrayLayer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetBarrier),
            "::",
            stringify!(mArrayLayer)
        )
    );
}
impl RenderTargetBarrier {
    #[inline]
    pub fn mBeginOnly(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mBeginOnly(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mEndOnly(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mEndOnly(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAcquire(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAcquire(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRelease(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRelease(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mQueueType(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_mQueueType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mSubresourceBarrier(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSubresourceBarrier(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMipLevel(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_mMipLevel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mBeginOnly: u8,
        mEndOnly: u8,
        mAcquire: u8,
        mRelease: u8,
        mQueueType: u8,
        mSubresourceBarrier: u8,
        mMipLevel: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mBeginOnly: u8 = unsafe { ::std::mem::transmute(mBeginOnly) };
            mBeginOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mEndOnly: u8 = unsafe { ::std::mem::transmute(mEndOnly) };
            mEndOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mAcquire: u8 = unsafe { ::std::mem::transmute(mAcquire) };
            mAcquire as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRelease: u8 = unsafe { ::std::mem::transmute(mRelease) };
            mRelease as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let mQueueType: u8 = unsafe { ::std::mem::transmute(mQueueType) };
            mQueueType as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let mSubresourceBarrier: u8 = unsafe { ::std::mem::transmute(mSubresourceBarrier) };
            mSubresourceBarrier as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let mMipLevel: u8 = unsafe { ::std::mem::transmute(mMipLevel) };
            mMipLevel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadRange {
    pub mOffset: u64,
    pub mSize: u64,
}
#[test]
fn bindgen_test_layout_ReadRange() {
    assert_eq!(
        ::std::mem::size_of::<ReadRange>(),
        16usize,
        concat!("Size of: ", stringify!(ReadRange))
    );
    assert_eq!(
        ::std::mem::align_of::<ReadRange>(),
        8usize,
        concat!("Alignment of ", stringify!(ReadRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReadRange>())).mOffset as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ReadRange), "::", stringify!(mOffset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReadRange>())).mSize as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ReadRange), "::", stringify!(mSize))
    );
}
pub const QueryType_QUERY_TYPE_TIMESTAMP: QueryType = 0;
pub const QueryType_QUERY_TYPE_PIPELINE_STATISTICS: QueryType = 1;
pub const QueryType_QUERY_TYPE_OCCLUSION: QueryType = 2;
pub const QueryType_QUERY_TYPE_COUNT: QueryType = 3;
pub type QueryType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryPoolDesc {
    pub mType: QueryType,
    pub mQueryCount: u32,
    pub mNodeIndex: u32,
}
#[test]
fn bindgen_test_layout_QueryPoolDesc() {
    assert_eq!(
        ::std::mem::size_of::<QueryPoolDesc>(),
        12usize,
        concat!("Size of: ", stringify!(QueryPoolDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<QueryPoolDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(QueryPoolDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryPoolDesc>())).mType as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(QueryPoolDesc), "::", stringify!(mType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryPoolDesc>())).mQueryCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryPoolDesc),
            "::",
            stringify!(mQueryCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryPoolDesc>())).mNodeIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryPoolDesc),
            "::",
            stringify!(mNodeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDesc {
    pub mIndex: u32,
}
#[test]
fn bindgen_test_layout_QueryDesc() {
    assert_eq!(
        ::std::mem::size_of::<QueryDesc>(),
        4usize,
        concat!("Size of: ", stringify!(QueryDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<QueryDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(QueryDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).mIndex as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(QueryDesc), "::", stringify!(mIndex))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryPool {
    _unused: [u8; 0],
}
pub const SamplerRange_SAMPLER_RANGE_FULL: SamplerRange = 0;
pub const SamplerRange_SAMPLER_RANGE_NARROW: SamplerRange = 1;
pub type SamplerRange = ::std::os::raw::c_int;
pub const SamplerModelConversion_SAMPLER_MODEL_CONVERSION_RGB_IDENTITY: SamplerModelConversion = 0;
pub const SamplerModelConversion_SAMPLER_MODEL_CONVERSION_YCBCR_IDENTITY: SamplerModelConversion = 1;
pub const SamplerModelConversion_SAMPLER_MODEL_CONVERSION_YCBCR_709: SamplerModelConversion = 2;
pub const SamplerModelConversion_SAMPLER_MODEL_CONVERSION_YCBCR_601: SamplerModelConversion = 3;
pub const SamplerModelConversion_SAMPLER_MODEL_CONVERSION_YCBCR_2020: SamplerModelConversion = 4;
pub type SamplerModelConversion = ::std::os::raw::c_int;
pub const SampleLocation_SAMPLE_LOCATION_COSITED: SampleLocation = 0;
pub const SampleLocation_SAMPLE_LOCATION_MIDPOINT: SampleLocation = 1;
pub type SampleLocation = ::std::os::raw::c_int;
#[doc = " Data structure holding necessary info to create a Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferDesc {
    #[doc = " Size of the buffer (in bytes)"]
    pub mSize: u64,
    #[doc = " Set this to specify a counter buffer for this buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)"]
    pub pCounterBuffer: *mut Buffer,
    #[doc = " Index of the first element accessible by the SRV/UAV (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)"]
    pub mFirstElement: u64,
    #[doc = " Number of elements in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)"]
    pub mElementCount: u64,
    #[doc = " Size of each element (in bytes) in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)"]
    pub mStructStride: u64,
    #[doc = " Debug name used in gpu profile"]
    pub pName: *const ::std::os::raw::c_char,
    pub pSharedNodeIndices: *mut u32,
    #[doc = " Alignment"]
    pub mAlignment: u32,
    #[doc = " Decides which memory heap buffer will use (default, upload, readback)"]
    pub mMemoryUsage: ResourceMemoryUsage,
    #[doc = " Creation flags of the buffer"]
    pub mFlags: BufferCreationFlags,
    #[doc = " What type of queue the buffer is owned by"]
    pub mQueueType: QueueType,
    #[doc = " What state will the buffer get created in"]
    pub mStartState: ResourceState,
    #[doc = " ICB draw type"]
    pub mICBDrawType: IndirectArgumentType,
    #[doc = " ICB max vertex buffers slots count"]
    pub mICBMaxVertexBufferBind: u32,
    #[doc = " ICB max vertex buffers slots count"]
    pub mICBMaxFragmentBufferBind: u32,
    #[doc = " Format of the buffer (applicable to typed storage buffers (Buffer<T>)"]
    pub mFormat: TinyImageFormat,
    #[doc = " Flags specifying the suitable usage of this buffer (Uniform buffer, Vertex Buffer, Index Buffer,...)"]
    pub mDescriptors: DescriptorType,
    pub mNodeIndex: u32,
    pub mSharedNodeIndexCount: u32,
}
#[test]
fn bindgen_test_layout_BufferDesc() {
    assert_eq!(
        ::std::mem::size_of::<BufferDesc>(),
        104usize,
        concat!("Size of: ", stringify!(BufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<BufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(BufferDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mSize as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BufferDesc), "::", stringify!(mSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).pCounterBuffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(pCounterBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mFirstElement as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mFirstElement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mElementCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mElementCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mStructStride as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mStructStride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).pName as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(BufferDesc), "::", stringify!(pName))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).pSharedNodeIndices as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(pSharedNodeIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mAlignment as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mMemoryUsage as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mMemoryUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mFlags as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(BufferDesc), "::", stringify!(mFlags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mQueueType as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mQueueType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mStartState as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mStartState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mICBDrawType as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mICBDrawType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mICBMaxVertexBufferBind as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mICBMaxVertexBufferBind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mICBMaxFragmentBufferBind as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mICBMaxFragmentBufferBind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mFormat as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(BufferDesc), "::", stringify!(mFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mDescriptors as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mDescriptors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mNodeIndex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mNodeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferDesc>())).mSharedNodeIndexCount as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferDesc),
            "::",
            stringify!(mSharedNodeIndexCount)
        )
    );
}
#[doc = " Data structure holding necessary info to create a Texture"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TextureDesc {
    #[doc = " Optimized clear value (recommended to use this same value when clearing the rendertarget)"]
    pub mClearValue: ClearValue,
    #[doc = " Pointer to native texture handle if the texture does not own underlying resource"]
    pub pNativeHandle: *const ::std::os::raw::c_void,
    #[doc = " Debug name used in gpu profile"]
    pub pName: *const ::std::os::raw::c_char,
    #[doc = " GPU indices to share this texture"]
    pub pSharedNodeIndices: *mut u32,
    pub pVkSamplerYcbcrConversionInfo: *mut ::std::os::raw::c_void,
    #[doc = " Texture creation flags (decides memory allocation strategy, sharing access,...)"]
    pub mFlags: TextureCreationFlags,
    #[doc = " Width"]
    pub mWidth: u32,
    #[doc = " Height"]
    pub mHeight: u32,
    #[doc = " Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)"]
    pub mDepth: u32,
    #[doc = " Texture array size (Should be 1 if texture is not a texture array or cubemap)"]
    pub mArraySize: u32,
    #[doc = " Number of mip levels"]
    pub mMipLevels: u32,
    #[doc = " Number of multisamples per pixel (currently Textures created with mUsage TEXTURE_USAGE_SAMPLED_IMAGE only support SAMPLE_COUNT_1)"]
    pub mSampleCount: SampleCount,
    #[doc = " The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value appropriate for mSampleCount"]
    pub mSampleQuality: u32,
    #[doc = "  image format"]
    pub mFormat: TinyImageFormat,
    #[doc = " What state will the texture get created in"]
    pub mStartState: ResourceState,
    #[doc = " Descriptor creation"]
    pub mDescriptors: DescriptorType,
    #[doc = " Number of GPUs to share this texture"]
    pub mSharedNodeIndexCount: u32,
    #[doc = " GPU which will own this texture"]
    pub mNodeIndex: u32,
}
#[test]
fn bindgen_test_layout_TextureDesc() {
    assert_eq!(
        ::std::mem::size_of::<TextureDesc>(),
        104usize,
        concat!("Size of: ", stringify!(TextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<TextureDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(TextureDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mClearValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mClearValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).pNativeHandle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(pNativeHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).pName as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(TextureDesc), "::", stringify!(pName))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).pSharedNodeIndices as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(pSharedNodeIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).pVkSamplerYcbcrConversionInfo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(pVkSamplerYcbcrConversionInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mFlags as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(TextureDesc), "::", stringify!(mFlags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mWidth as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(TextureDesc), "::", stringify!(mWidth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mHeight as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(TextureDesc), "::", stringify!(mHeight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mDepth as *const _ as usize },
        60usize,
        concat!("Offset of field: ", stringify!(TextureDesc), "::", stringify!(mDepth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mArraySize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mArraySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mMipLevels as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mMipLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mSampleCount as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mSampleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mSampleQuality as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mSampleQuality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mFormat as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(TextureDesc), "::", stringify!(mFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mStartState as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mStartState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mDescriptors as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mDescriptors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mSharedNodeIndexCount as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mSharedNodeIndexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TextureDesc>())).mNodeIndex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TextureDesc),
            "::",
            stringify!(mNodeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtualTexturePage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtualTexture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderTargetDesc {
    #[doc = " Texture creation flags (decides memory allocation strategy, sharing access,...)"]
    pub mFlags: TextureCreationFlags,
    #[doc = " Width"]
    pub mWidth: u32,
    #[doc = " Height"]
    pub mHeight: u32,
    #[doc = " Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)"]
    pub mDepth: u32,
    #[doc = " Texture array size (Should be 1 if texture is not a texture array or cubemap)"]
    pub mArraySize: u32,
    #[doc = " Number of mip levels"]
    pub mMipLevels: u32,
    #[doc = " MSAA"]
    pub mSampleCount: SampleCount,
    #[doc = " Internal image format"]
    pub mFormat: TinyImageFormat,
    #[doc = " What state will the texture get created in"]
    pub mStartState: ResourceState,
    #[doc = " Optimized clear value (recommended to use this same value when clearing the rendertarget)"]
    pub mClearValue: ClearValue,
    #[doc = " The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value appropriate for mSampleCount"]
    pub mSampleQuality: u32,
    #[doc = " Descriptor creation"]
    pub mDescriptors: DescriptorType,
    pub pNativeHandle: *const ::std::os::raw::c_void,
    #[doc = " Debug name used in gpu profile"]
    pub pName: *const ::std::os::raw::c_char,
    #[doc = " GPU indices to share this texture"]
    pub pSharedNodeIndices: *mut u32,
    #[doc = " Number of GPUs to share this texture"]
    pub mSharedNodeIndexCount: u32,
    #[doc = " GPU which will own this texture"]
    pub mNodeIndex: u32,
}
#[test]
fn bindgen_test_layout_RenderTargetDesc() {
    assert_eq!(
        ::std::mem::size_of::<RenderTargetDesc>(),
        96usize,
        concat!("Size of: ", stringify!(RenderTargetDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RenderTargetDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(RenderTargetDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mHeight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mDepth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mArraySize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mArraySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mMipLevels as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mMipLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mSampleCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mSampleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mFormat as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mStartState as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mStartState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mClearValue as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mClearValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mSampleQuality as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mSampleQuality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mDescriptors as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mDescriptors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).pNativeHandle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(pNativeHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).pName as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(pName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).pSharedNodeIndices as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(pSharedNodeIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mSharedNodeIndexCount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mSharedNodeIndexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTargetDesc>())).mNodeIndex as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTargetDesc),
            "::",
            stringify!(mNodeIndex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LoadActionsDesc {
    pub mClearColorValues: [ClearValue; 8usize],
    pub mLoadActionsColor: [LoadActionType; 8usize],
    pub mClearDepth: ClearValue,
    pub mLoadActionDepth: LoadActionType,
    pub mLoadActionStencil: LoadActionType,
}
#[test]
fn bindgen_test_layout_LoadActionsDesc() {
    assert_eq!(
        ::std::mem::size_of::<LoadActionsDesc>(),
        184usize,
        concat!("Size of: ", stringify!(LoadActionsDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<LoadActionsDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(LoadActionsDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadActionsDesc>())).mClearColorValues as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadActionsDesc),
            "::",
            stringify!(mClearColorValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadActionsDesc>())).mLoadActionsColor as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadActionsDesc),
            "::",
            stringify!(mLoadActionsColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadActionsDesc>())).mClearDepth as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadActionsDesc),
            "::",
            stringify!(mClearDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadActionsDesc>())).mLoadActionDepth as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadActionsDesc),
            "::",
            stringify!(mLoadActionDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadActionsDesc>())).mLoadActionStencil as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadActionsDesc),
            "::",
            stringify!(mLoadActionStencil)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerDesc {
    pub mMinFilter: FilterType,
    pub mMagFilter: FilterType,
    pub mMipMapMode: MipMapMode,
    pub mAddressU: AddressMode,
    pub mAddressV: AddressMode,
    pub mAddressW: AddressMode,
    pub mMipLodBias: f32,
    pub mMaxAnisotropy: f32,
    pub mCompareFunc: CompareMode,
    pub mSamplerConversionDesc: SamplerDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerDesc__bindgen_ty_1 {
    pub mFormat: TinyImageFormat,
    pub mModel: SamplerModelConversion,
    pub mRange: SamplerRange,
    pub mChromaOffsetX: SampleLocation,
    pub mChromaOffsetY: SampleLocation,
    pub mChromaFilter: FilterType,
    pub mForceExplicitReconstruction: bool,
}
#[test]
fn bindgen_test_layout_SamplerDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SamplerDesc__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(SamplerDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SamplerDesc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SamplerDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mFormat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mModel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mModel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mRange as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mRange)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mChromaOffsetX as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mChromaOffsetX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mChromaOffsetY as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mChromaOffsetY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mChromaFilter as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mChromaFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SamplerDesc__bindgen_ty_1>())).mForceExplicitReconstruction as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc__bindgen_ty_1),
            "::",
            stringify!(mForceExplicitReconstruction)
        )
    );
}
#[test]
fn bindgen_test_layout_SamplerDesc() {
    assert_eq!(
        ::std::mem::size_of::<SamplerDesc>(),
        64usize,
        concat!("Size of: ", stringify!(SamplerDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<SamplerDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(SamplerDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mMinFilter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mMinFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mMagFilter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mMagFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mMipMapMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mMipMapMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mAddressU as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mAddressU)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mAddressV as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mAddressV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mAddressW as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mAddressW)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mMipLodBias as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mMipLodBias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mMaxAnisotropy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mMaxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mCompareFunc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mCompareFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SamplerDesc>())).mSamplerConversionDesc as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SamplerDesc),
            "::",
            stringify!(mSamplerConversionDesc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sampler {
    _unused: [u8; 0],
}
pub const DescriptorUpdateFrequency_DESCRIPTOR_UPDATE_FREQ_NONE: DescriptorUpdateFrequency = 0;
pub const DescriptorUpdateFrequency_DESCRIPTOR_UPDATE_FREQ_PER_FRAME: DescriptorUpdateFrequency = 1;
pub const DescriptorUpdateFrequency_DESCRIPTOR_UPDATE_FREQ_PER_BATCH: DescriptorUpdateFrequency = 2;
pub const DescriptorUpdateFrequency_DESCRIPTOR_UPDATE_FREQ_PER_DRAW: DescriptorUpdateFrequency = 3;
pub const DescriptorUpdateFrequency_DESCRIPTOR_UPDATE_FREQ_COUNT: DescriptorUpdateFrequency = 4;
pub type DescriptorUpdateFrequency = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorInfo {
    _unused: [u8; 0],
}
#[doc = " Default flag"]
pub const RootSignatureFlags_ROOT_SIGNATURE_FLAG_NONE: RootSignatureFlags = 0;
#[doc = " Local root signature used mainly in raytracing shaders"]
pub const RootSignatureFlags_ROOT_SIGNATURE_FLAG_LOCAL_BIT: RootSignatureFlags = 1;
pub type RootSignatureFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootSignatureDesc {
    pub ppShaders: *mut *mut Shader,
    pub mShaderCount: u32,
    pub mMaxBindlessTextures: u32,
    pub ppStaticSamplerNames: *mut *const ::std::os::raw::c_char,
    pub ppStaticSamplers: *mut *mut Sampler,
    pub mStaticSamplerCount: u32,
    pub mFlags: RootSignatureFlags,
}
#[test]
fn bindgen_test_layout_RootSignatureDesc() {
    assert_eq!(
        ::std::mem::size_of::<RootSignatureDesc>(),
        40usize,
        concat!("Size of: ", stringify!(RootSignatureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RootSignatureDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(RootSignatureDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).ppShaders as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(ppShaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).mShaderCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(mShaderCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).mMaxBindlessTextures as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(mMaxBindlessTextures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).ppStaticSamplerNames as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(ppStaticSamplerNames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).ppStaticSamplers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(ppStaticSamplers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).mStaticSamplerCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(mStaticSamplerCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RootSignatureDesc>())).mFlags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSignatureDesc),
            "::",
            stringify!(mFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootSignature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DescriptorData {
    #[doc = " User can either set name of descriptor or index (index in pRootSignature->pDescriptors array)"]
    #[doc = " Name of descriptor"]
    pub pName: *const ::std::os::raw::c_char,
    pub __bindgen_anon_1: DescriptorData__bindgen_ty_1,
    pub __bindgen_anon_2: DescriptorData__bindgen_ty_2,
    #[doc = " Number of resources in the descriptor(applies to array of textures, buffers,...)"]
    pub mCount: u32,
    pub mIndex: u32,
    pub mExtractBuffer: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DescriptorData__bindgen_ty_1 {
    pub __bindgen_anon_1: DescriptorData__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: DescriptorData__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: DescriptorData__bindgen_ty_1__bindgen_ty_3,
    pub mBindStencilResource: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorData__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Offset to bind the buffer descriptor"]
    pub pOffsets: *const u64,
    pub pSizes: *const u64,
}
#[test]
fn bindgen_test_layout_DescriptorData__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorData__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorData__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_1>())).pOffsets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_1>())).pSizes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pSizes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorData__bindgen_ty_1__bindgen_ty_2 {
    pub mDescriptorSetShader: *mut Shader,
    pub mDescriptorSetBufferIndex: u32,
    pub mDescriptorSetShaderStage: ShaderStage,
}
#[test]
fn bindgen_test_layout_DescriptorData__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorData__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorData__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_2>())).mDescriptorSetShader as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mDescriptorSetShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_2>())).mDescriptorSetBufferIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mDescriptorSetBufferIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_2>())).mDescriptorSetShaderStage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mDescriptorSetShaderStage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorData__bindgen_ty_1__bindgen_ty_3 {
    pub mUAVMipSlice: u32,
    pub mBindMipChain: bool,
}
#[test]
fn bindgen_test_layout_DescriptorData__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorData__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorData__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_3>())).mUAVMipSlice as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(mUAVMipSlice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1__bindgen_ty_3>())).mBindMipChain as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(mBindMipChain)
        )
    );
}
#[test]
fn bindgen_test_layout_DescriptorData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorData__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(DescriptorData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorData__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(DescriptorData__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_1>())).mBindStencilResource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_1),
            "::",
            stringify!(mBindStencilResource)
        )
    );
}
#[doc = " Array of resources containing descriptor handles or constant to be used in ring buffer memory - DescriptorRange can hold only one resource type array"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union DescriptorData__bindgen_ty_2 {
    #[doc = " Array of texture descriptors (srv and uav textures)"]
    pub ppTextures: *mut *mut Texture,
    #[doc = " Array of sampler descriptors"]
    pub ppSamplers: *mut *mut Sampler,
    #[doc = " Array of buffer descriptors (srv, uav and cbv buffers)"]
    pub ppBuffers: *mut *mut Buffer,
    #[doc = " Array of pipeline descriptors"]
    pub ppPipelines: *mut *mut Pipeline,
    #[doc = " DescriptorSet buffer extraction"]
    pub ppDescriptorSet: *mut *mut DescriptorSet,
    #[doc = " Custom binding (raytracing acceleration structure ...)"]
    pub ppAccelerationStructures: *mut *mut AccelerationStructure,
}
#[test]
fn bindgen_test_layout_DescriptorData__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorData__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(DescriptorData__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorData__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(DescriptorData__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_2>())).ppTextures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_2),
            "::",
            stringify!(ppTextures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_2>())).ppSamplers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_2),
            "::",
            stringify!(ppSamplers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_2>())).ppBuffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_2),
            "::",
            stringify!(ppBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_2>())).ppPipelines as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_2),
            "::",
            stringify!(ppPipelines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData__bindgen_ty_2>())).ppDescriptorSet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_2),
            "::",
            stringify!(ppDescriptorSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DescriptorData__bindgen_ty_2>())).ppAccelerationStructures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData__bindgen_ty_2),
            "::",
            stringify!(ppAccelerationStructures)
        )
    );
}
#[test]
fn bindgen_test_layout_DescriptorData() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorData>(),
        48usize,
        concat!("Size of: ", stringify!(DescriptorData))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorData>(),
        8usize,
        concat!("Alignment of ", stringify!(DescriptorData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData>())).pName as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DescriptorData), "::", stringify!(pName))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData>())).mCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData),
            "::",
            stringify!(mCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData>())).mIndex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData),
            "::",
            stringify!(mIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorData>())).mExtractBuffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorData),
            "::",
            stringify!(mExtractBuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CmdPoolDesc {
    pub pQueue: *mut Queue,
    pub mTransient: bool,
}
#[test]
fn bindgen_test_layout_CmdPoolDesc() {
    assert_eq!(
        ::std::mem::size_of::<CmdPoolDesc>(),
        16usize,
        concat!("Size of: ", stringify!(CmdPoolDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<CmdPoolDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(CmdPoolDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CmdPoolDesc>())).pQueue as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CmdPoolDesc), "::", stringify!(pQueue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CmdPoolDesc>())).mTransient as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CmdPoolDesc),
            "::",
            stringify!(mTransient)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CmdPool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CmdDesc {
    _unused: [u8; 0],
}
pub const MarkerType_MARKER_TYPE_DEFAULT: MarkerType = 0;
pub const MarkerType_MARKER_TYPE_IN: MarkerType = 1;
pub const MarkerType_MARKER_TYPE_OUT: MarkerType = 2;
pub const MarkerType_MARKER_TYPE_IN_OUT: MarkerType = 3;
pub type MarkerType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cmd {
    _unused: [u8; 0],
}
pub const FenceStatus_FENCE_STATUS_COMPLETE: FenceStatus = 0;
pub const FenceStatus_FENCE_STATUS_INCOMPLETE: FenceStatus = 1;
pub const FenceStatus_FENCE_STATUS_NOTSUBMITTED: FenceStatus = 2;
pub type FenceStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fence {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Semaphore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDesc {
    pub mType: QueueType,
    pub mFlag: QueueFlag,
    pub mPriority: QueuePriority,
    pub mNodeIndex: u32,
}
#[test]
fn bindgen_test_layout_QueueDesc() {
    assert_eq!(
        ::std::mem::size_of::<QueueDesc>(),
        16usize,
        concat!("Size of: ", stringify!(QueueDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<QueueDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(QueueDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueDesc>())).mType as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(QueueDesc), "::", stringify!(mType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueDesc>())).mFlag as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(QueueDesc), "::", stringify!(mFlag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueDesc>())).mPriority as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(QueueDesc), "::", stringify!(mPriority))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueDesc>())).mNodeIndex as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(QueueDesc), "::", stringify!(mNodeIndex))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderMacro {
    pub definition: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ShaderMacro() {
    assert_eq!(
        ::std::mem::size_of::<ShaderMacro>(),
        16usize,
        concat!("Size of: ", stringify!(ShaderMacro))
    );
    assert_eq!(
        ::std::mem::align_of::<ShaderMacro>(),
        8usize,
        concat!("Alignment of ", stringify!(ShaderMacro))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderMacro>())).definition as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ShaderMacro),
            "::",
            stringify!(definition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShaderMacro>())).value as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ShaderMacro), "::", stringify!(value))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BinaryShaderStageDesc {
    #[doc = " Byte code array"]
    pub pByteCode: *mut ::std::os::raw::c_void,
    pub mByteCodeSize: u32,
    pub pEntryPoint: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BinaryShaderStageDesc() {
    assert_eq!(
        ::std::mem::size_of::<BinaryShaderStageDesc>(),
        24usize,
        concat!("Size of: ", stringify!(BinaryShaderStageDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<BinaryShaderStageDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(BinaryShaderStageDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderStageDesc>())).pByteCode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderStageDesc),
            "::",
            stringify!(pByteCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderStageDesc>())).mByteCodeSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderStageDesc),
            "::",
            stringify!(mByteCodeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderStageDesc>())).pEntryPoint as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderStageDesc),
            "::",
            stringify!(pEntryPoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BinaryShaderDesc {
    pub mStages: ShaderStage,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mVert: BinaryShaderStageDesc,
    pub mFrag: BinaryShaderStageDesc,
    pub mGeom: BinaryShaderStageDesc,
    pub mHull: BinaryShaderStageDesc,
    pub mDomain: BinaryShaderStageDesc,
    pub mComp: BinaryShaderStageDesc,
}
#[test]
fn bindgen_test_layout_BinaryShaderDesc() {
    assert_eq!(
        ::std::mem::size_of::<BinaryShaderDesc>(),
        152usize,
        concat!("Size of: ", stringify!(BinaryShaderDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<BinaryShaderDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(BinaryShaderDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mStages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mStages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mVert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mVert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mFrag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mFrag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mGeom as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mGeom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mHull as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mHull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mDomain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mDomain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BinaryShaderDesc>())).mComp as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryShaderDesc),
            "::",
            stringify!(mComp)
        )
    );
}
impl BinaryShaderDesc {
    #[inline]
    pub fn mOwnByteCode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mOwnByteCode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mOwnByteCode: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mOwnByteCode: u32 = unsafe { ::std::mem::transmute(mOwnByteCode) };
            mOwnByteCode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlendStateDesc {
    #[doc = " Source blend factor per render target."]
    pub mSrcFactors: [BlendConstant; 8usize],
    #[doc = " Destination blend factor per render target."]
    pub mDstFactors: [BlendConstant; 8usize],
    #[doc = " Source alpha blend factor per render target."]
    pub mSrcAlphaFactors: [BlendConstant; 8usize],
    #[doc = " Destination alpha blend factor per render target."]
    pub mDstAlphaFactors: [BlendConstant; 8usize],
    #[doc = " Blend mode per render target."]
    pub mBlendModes: [BlendMode; 8usize],
    #[doc = " Alpha blend mode per render target."]
    pub mBlendAlphaModes: [BlendMode; 8usize],
    #[doc = " Write mask per render target."]
    pub mMasks: [i32; 8usize],
    #[doc = " Mask that identifies the render targets affected by the blend state."]
    pub mRenderTargetMask: BlendStateTargets,
    #[doc = " Set whether alpha to coverage should be enabled."]
    pub mAlphaToCoverage: bool,
    #[doc = " Set whether each render target has an unique blend function. When false the blend function in slot 0 will be used for all render targets."]
    pub mIndependentBlend: bool,
}
#[test]
fn bindgen_test_layout_BlendStateDesc() {
    assert_eq!(
        ::std::mem::size_of::<BlendStateDesc>(),
        232usize,
        concat!("Size of: ", stringify!(BlendStateDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<BlendStateDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(BlendStateDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mSrcFactors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mSrcFactors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mDstFactors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mDstFactors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mSrcAlphaFactors as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mSrcAlphaFactors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mDstAlphaFactors as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mDstAlphaFactors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mBlendModes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mBlendModes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mBlendAlphaModes as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mBlendAlphaModes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mMasks as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mMasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mRenderTargetMask as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mRenderTargetMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mAlphaToCoverage as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mAlphaToCoverage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlendStateDesc>())).mIndependentBlend as *const _ as usize },
        229usize,
        concat!(
            "Offset of field: ",
            stringify!(BlendStateDesc),
            "::",
            stringify!(mIndependentBlend)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DepthStateDesc {
    pub mDepthTest: bool,
    pub mDepthWrite: bool,
    pub mDepthFunc: CompareMode,
    pub mStencilTest: bool,
    pub mStencilReadMask: u8,
    pub mStencilWriteMask: u8,
    pub mStencilFrontFunc: CompareMode,
    pub mStencilFrontFail: StencilOp,
    pub mDepthFrontFail: StencilOp,
    pub mStencilFrontPass: StencilOp,
    pub mStencilBackFunc: CompareMode,
    pub mStencilBackFail: StencilOp,
    pub mDepthBackFail: StencilOp,
    pub mStencilBackPass: StencilOp,
}
#[test]
fn bindgen_test_layout_DepthStateDesc() {
    assert_eq!(
        ::std::mem::size_of::<DepthStateDesc>(),
        44usize,
        concat!("Size of: ", stringify!(DepthStateDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<DepthStateDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(DepthStateDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mDepthTest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mDepthTest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mDepthWrite as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mDepthWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mDepthFunc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mDepthFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilTest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilTest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilReadMask as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilReadMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilWriteMask as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilWriteMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilFrontFunc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilFrontFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilFrontFail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilFrontFail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mDepthFrontFail as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mDepthFrontFail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilFrontPass as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilFrontPass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilBackFunc as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilBackFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilBackFail as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilBackFail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mDepthBackFail as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mDepthBackFail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DepthStateDesc>())).mStencilBackPass as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DepthStateDesc),
            "::",
            stringify!(mStencilBackPass)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RasterizerStateDesc {
    pub mCullMode: CullMode,
    pub mDepthBias: i32,
    pub mSlopeScaledDepthBias: f32,
    pub mFillMode: FillMode,
    pub mFrontFace: FrontFace,
    pub mMultiSample: bool,
    pub mScissor: bool,
    pub mDepthClampEnable: bool,
}
#[test]
fn bindgen_test_layout_RasterizerStateDesc() {
    assert_eq!(
        ::std::mem::size_of::<RasterizerStateDesc>(),
        24usize,
        concat!("Size of: ", stringify!(RasterizerStateDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RasterizerStateDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(RasterizerStateDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mCullMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mCullMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mDepthBias as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mDepthBias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mSlopeScaledDepthBias as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mSlopeScaledDepthBias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mFillMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mFillMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mFrontFace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mFrontFace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mMultiSample as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mMultiSample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mScissor as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mScissor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RasterizerStateDesc>())).mDepthClampEnable as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(RasterizerStateDesc),
            "::",
            stringify!(mDepthClampEnable)
        )
    );
}
pub const VertexAttribRate_VERTEX_ATTRIB_RATE_VERTEX: VertexAttribRate = 0;
pub const VertexAttribRate_VERTEX_ATTRIB_RATE_INSTANCE: VertexAttribRate = 1;
pub const VertexAttribRate_VERTEX_ATTRIB_RATE_COUNT: VertexAttribRate = 2;
pub type VertexAttribRate = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexAttrib {
    pub mSemantic: ShaderSemantic,
    pub mSemanticNameLength: u32,
    pub mSemanticName: [::std::os::raw::c_char; 128usize],
    pub mFormat: TinyImageFormat,
    pub mBinding: u32,
    pub mLocation: u32,
    pub mOffset: u32,
    pub mRate: VertexAttribRate,
}
#[test]
fn bindgen_test_layout_VertexAttrib() {
    assert_eq!(
        ::std::mem::size_of::<VertexAttrib>(),
        156usize,
        concat!("Size of: ", stringify!(VertexAttrib))
    );
    assert_eq!(
        ::std::mem::align_of::<VertexAttrib>(),
        4usize,
        concat!("Alignment of ", stringify!(VertexAttrib))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mSemantic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexAttrib),
            "::",
            stringify!(mSemantic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mSemanticNameLength as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexAttrib),
            "::",
            stringify!(mSemanticNameLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mSemanticName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexAttrib),
            "::",
            stringify!(mSemanticName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mFormat as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(VertexAttrib), "::", stringify!(mFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mBinding as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexAttrib),
            "::",
            stringify!(mBinding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mLocation as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexAttrib),
            "::",
            stringify!(mLocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mOffset as *const _ as usize },
        148usize,
        concat!("Offset of field: ", stringify!(VertexAttrib), "::", stringify!(mOffset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexAttrib>())).mRate as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(VertexAttrib), "::", stringify!(mRate))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexLayout {
    pub mAttribCount: u32,
    pub mAttribs: [VertexAttrib; 15usize],
}
#[test]
fn bindgen_test_layout_VertexLayout() {
    assert_eq!(
        ::std::mem::size_of::<VertexLayout>(),
        2344usize,
        concat!("Size of: ", stringify!(VertexLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<VertexLayout>(),
        4usize,
        concat!("Alignment of ", stringify!(VertexLayout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexLayout>())).mAttribCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexLayout),
            "::",
            stringify!(mAttribCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VertexLayout>())).mAttribs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VertexLayout),
            "::",
            stringify!(mAttribs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RaytracingPipelineDesc {
    pub pRaytracing: *mut Raytracing,
    pub pGlobalRootSignature: *mut RootSignature,
    pub pRayGenShader: *mut Shader,
    pub pRayGenRootSignature: *mut RootSignature,
    pub ppMissShaders: *mut *mut Shader,
    pub ppMissRootSignatures: *mut *mut RootSignature,
    pub pHitGroups: *mut RaytracingHitGroup,
    pub pEmptyRootSignature: *mut RootSignature,
    pub mMissShaderCount: ::std::os::raw::c_uint,
    pub mHitGroupCount: ::std::os::raw::c_uint,
    pub mPayloadSize: ::std::os::raw::c_uint,
    pub mAttributeSize: ::std::os::raw::c_uint,
    pub mMaxTraceRecursionDepth: ::std::os::raw::c_uint,
    pub mMaxRaysCount: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_RaytracingPipelineDesc() {
    assert_eq!(
        ::std::mem::size_of::<RaytracingPipelineDesc>(),
        88usize,
        concat!("Size of: ", stringify!(RaytracingPipelineDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RaytracingPipelineDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(RaytracingPipelineDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).pRaytracing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(pRaytracing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).pGlobalRootSignature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(pGlobalRootSignature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).pRayGenShader as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(pRayGenShader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).pRayGenRootSignature as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(pRayGenRootSignature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).ppMissShaders as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(ppMissShaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).ppMissRootSignatures as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(ppMissRootSignatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).pHitGroups as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(pHitGroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).pEmptyRootSignature as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(pEmptyRootSignature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).mMissShaderCount as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(mMissShaderCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).mHitGroupCount as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(mHitGroupCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).mPayloadSize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(mPayloadSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).mAttributeSize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(mAttributeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).mMaxTraceRecursionDepth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(mMaxTraceRecursionDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RaytracingPipelineDesc>())).mMaxRaysCount as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RaytracingPipelineDesc),
            "::",
            stringify!(mMaxRaysCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GraphicsPipelineDesc {
    pub pShaderProgram: *mut Shader,
    pub pRootSignature: *mut RootSignature,
    pub pVertexLayout: *mut VertexLayout,
    pub pBlendState: *mut BlendStateDesc,
    pub pDepthState: *mut DepthStateDesc,
    pub pRasterizerState: *mut RasterizerStateDesc,
    pub pColorFormats: *mut TinyImageFormat,
    pub mRenderTargetCount: u32,
    pub mSampleCount: SampleCount,
    pub mSampleQuality: u32,
    pub mDepthStencilFormat: TinyImageFormat,
    pub mPrimitiveTopo: PrimitiveTopology,
    pub mSupportIndirectCommandBuffer: bool,
    pub mVRFoveatedRendering: bool,
}
#[test]
fn bindgen_test_layout_GraphicsPipelineDesc() {
    assert_eq!(
        ::std::mem::size_of::<GraphicsPipelineDesc>(),
        80usize,
        concat!("Size of: ", stringify!(GraphicsPipelineDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<GraphicsPipelineDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(GraphicsPipelineDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pShaderProgram as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pShaderProgram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pRootSignature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pRootSignature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pVertexLayout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pVertexLayout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pBlendState as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pBlendState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pDepthState as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pDepthState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pRasterizerState as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pRasterizerState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).pColorFormats as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(pColorFormats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mRenderTargetCount as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mRenderTargetCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mSampleCount as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mSampleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mSampleQuality as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mSampleQuality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mDepthStencilFormat as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mDepthStencilFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mPrimitiveTopo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mPrimitiveTopo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mSupportIndirectCommandBuffer as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mSupportIndirectCommandBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GraphicsPipelineDesc>())).mVRFoveatedRendering as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(GraphicsPipelineDesc),
            "::",
            stringify!(mVRFoveatedRendering)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputePipelineDesc {
    pub pShaderProgram: *mut Shader,
    pub pRootSignature: *mut RootSignature,
}
#[test]
fn bindgen_test_layout_ComputePipelineDesc() {
    assert_eq!(
        ::std::mem::size_of::<ComputePipelineDesc>(),
        16usize,
        concat!("Size of: ", stringify!(ComputePipelineDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<ComputePipelineDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(ComputePipelineDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ComputePipelineDesc>())).pShaderProgram as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputePipelineDesc),
            "::",
            stringify!(pShaderProgram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ComputePipelineDesc>())).pRootSignature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputePipelineDesc),
            "::",
            stringify!(pRootSignature)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineDesc {
    pub __bindgen_anon_1: PipelineDesc__bindgen_ty_1,
    pub pCache: *mut PipelineCache,
    pub pPipelineExtensions: *mut ::std::os::raw::c_void,
    pub pName: *const ::std::os::raw::c_char,
    pub mType: PipelineType,
    pub mExtensionCount: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PipelineDesc__bindgen_ty_1 {
    pub mComputeDesc: ComputePipelineDesc,
    pub mGraphicsDesc: GraphicsPipelineDesc,
    pub mRaytracingDesc: RaytracingPipelineDesc,
}
#[test]
fn bindgen_test_layout_PipelineDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PipelineDesc__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(PipelineDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<PipelineDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(PipelineDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc__bindgen_ty_1>())).mComputeDesc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineDesc__bindgen_ty_1),
            "::",
            stringify!(mComputeDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc__bindgen_ty_1>())).mGraphicsDesc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineDesc__bindgen_ty_1),
            "::",
            stringify!(mGraphicsDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc__bindgen_ty_1>())).mRaytracingDesc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineDesc__bindgen_ty_1),
            "::",
            stringify!(mRaytracingDesc)
        )
    );
}
#[test]
fn bindgen_test_layout_PipelineDesc() {
    assert_eq!(
        ::std::mem::size_of::<PipelineDesc>(),
        120usize,
        concat!("Size of: ", stringify!(PipelineDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<PipelineDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(PipelineDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc>())).pCache as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(PipelineDesc), "::", stringify!(pCache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc>())).pPipelineExtensions as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineDesc),
            "::",
            stringify!(pPipelineExtensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc>())).pName as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(PipelineDesc), "::", stringify!(pName))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc>())).mType as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(PipelineDesc), "::", stringify!(mType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineDesc>())).mExtensionCount as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineDesc),
            "::",
            stringify!(mExtensionCount)
        )
    );
}
pub const PipelineCacheFlags_PIPELINE_CACHE_FLAG_NONE: PipelineCacheFlags = 0;
pub const PipelineCacheFlags_PIPELINE_CACHE_FLAG_EXTERNALLY_SYNCHRONIZED: PipelineCacheFlags = 1;
pub type PipelineCacheFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineCacheDesc {
    #[doc = " Initial pipeline cache data (can be NULL which means empty pipeline cache)"]
    pub pData: *mut ::std::os::raw::c_void,
    #[doc = " Initial pipeline cache size"]
    pub mSize: usize,
    pub mFlags: PipelineCacheFlags,
}
#[test]
fn bindgen_test_layout_PipelineCacheDesc() {
    assert_eq!(
        ::std::mem::size_of::<PipelineCacheDesc>(),
        24usize,
        concat!("Size of: ", stringify!(PipelineCacheDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<PipelineCacheDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(PipelineCacheDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineCacheDesc>())).pData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineCacheDesc),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineCacheDesc>())).mSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineCacheDesc),
            "::",
            stringify!(mSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PipelineCacheDesc>())).mFlags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PipelineCacheDesc),
            "::",
            stringify!(mFlags)
        )
    );
}
pub const SwapChainCreationFlags_SWAP_CHAIN_CREATION_FLAG_NONE: SwapChainCreationFlags = 0;
pub const SwapChainCreationFlags_SWAP_CHAIN_CREATION_FLAG_ENABLE_FOVEATED_RENDERING_VR: SwapChainCreationFlags = 1;
pub type SwapChainCreationFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwapChainDesc {
    #[doc = " Window handle"]
    pub mWindowHandle: WindowHandle,
    #[doc = " Queues which should be allowed to present"]
    pub ppPresentQueues: *mut *mut Queue,
    #[doc = " Number of present queues"]
    pub mPresentQueueCount: u32,
    #[doc = " Number of backbuffers in this swapchain"]
    pub mImageCount: u32,
    #[doc = " Width of the swapchain"]
    pub mWidth: u32,
    #[doc = " Height of the swapchain"]
    pub mHeight: u32,
    #[doc = " Color format of the swapchain"]
    pub mColorFormat: TinyImageFormat,
    #[doc = " Clear value"]
    pub mColorClearValue: ClearValue,
    #[doc = " Swapchain creation flags"]
    pub mFlags: SwapChainCreationFlags,
    #[doc = " Set whether swap chain will be presented using vsync"]
    pub mEnableVsync: bool,
    #[doc = " We can toggle to using FLIP model if app desires."]
    pub mUseFlipSwapEffect: bool,
}
#[test]
fn bindgen_test_layout_SwapChainDesc() {
    assert_eq!(
        ::std::mem::size_of::<SwapChainDesc>(),
        64usize,
        concat!("Size of: ", stringify!(SwapChainDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<SwapChainDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(SwapChainDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mWindowHandle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mWindowHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).ppPresentQueues as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(ppPresentQueues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mPresentQueueCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mPresentQueueCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mImageCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mImageCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mWidth as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(SwapChainDesc), "::", stringify!(mWidth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mHeight as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mColorFormat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mColorFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mColorClearValue as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mColorClearValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mFlags as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(SwapChainDesc), "::", stringify!(mFlags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mEnableVsync as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mEnableVsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwapChainDesc>())).mUseFlipSwapEffect as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(SwapChainDesc),
            "::",
            stringify!(mUseFlipSwapEffect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwapChain {
    _unused: [u8; 0],
}
pub const ShaderTarget_shader_target_5_1: ShaderTarget = 0;
pub const ShaderTarget_shader_target_6_0: ShaderTarget = 1;
pub const ShaderTarget_shader_target_6_1: ShaderTarget = 2;
pub const ShaderTarget_shader_target_6_2: ShaderTarget = 3;
pub const ShaderTarget_shader_target_6_3: ShaderTarget = 4;
pub const ShaderTarget_shader_target_6_4: ShaderTarget = 5;
pub type ShaderTarget = ::std::os::raw::c_int;
pub const GpuMode_GPU_MODE_SINGLE: GpuMode = 0;
pub const GpuMode_GPU_MODE_LINKED: GpuMode = 1;
pub type GpuMode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RendererDesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPUVendorPreset {
    pub mVendorId: [::std::os::raw::c_char; 64usize],
    pub mModelId: [::std::os::raw::c_char; 64usize],
    pub mRevisionId: [::std::os::raw::c_char; 64usize],
    pub mPresetLevel: GPUPresetLevel,
    pub mGpuName: [::std::os::raw::c_char; 64usize],
    pub mGpuDriverVersion: [::std::os::raw::c_char; 64usize],
    pub mGpuDriverDate: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_GPUVendorPreset() {
    assert_eq!(
        ::std::mem::size_of::<GPUVendorPreset>(),
        388usize,
        concat!("Size of: ", stringify!(GPUVendorPreset))
    );
    assert_eq!(
        ::std::mem::align_of::<GPUVendorPreset>(),
        4usize,
        concat!("Alignment of ", stringify!(GPUVendorPreset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mVendorId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mVendorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mModelId as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mModelId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mRevisionId as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mRevisionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mPresetLevel as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mPresetLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mGpuName as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mGpuName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mGpuDriverVersion as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mGpuDriverVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUVendorPreset>())).mGpuDriverDate as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUVendorPreset),
            "::",
            stringify!(mGpuDriverDate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPUCapBits {
    pub canShaderReadFrom: [bool; 239usize],
    pub canShaderWriteTo: [bool; 239usize],
    pub canRenderTargetWriteTo: [bool; 239usize],
}
#[test]
fn bindgen_test_layout_GPUCapBits() {
    assert_eq!(
        ::std::mem::size_of::<GPUCapBits>(),
        717usize,
        concat!("Size of: ", stringify!(GPUCapBits))
    );
    assert_eq!(
        ::std::mem::align_of::<GPUCapBits>(),
        1usize,
        concat!("Alignment of ", stringify!(GPUCapBits))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUCapBits>())).canShaderReadFrom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUCapBits),
            "::",
            stringify!(canShaderReadFrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUCapBits>())).canShaderWriteTo as *const _ as usize },
        239usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUCapBits),
            "::",
            stringify!(canShaderWriteTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUCapBits>())).canRenderTargetWriteTo as *const _ as usize },
        478usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUCapBits),
            "::",
            stringify!(canRenderTargetWriteTo)
        )
    );
}
pub const DefaultResourceAlignment_RESOURCE_BUFFER_ALIGNMENT: DefaultResourceAlignment = 4;
pub type DefaultResourceAlignment = ::std::os::raw::c_int;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_NONE: WaveOpsSupportFlags = 0;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_BASIC_BIT: WaveOpsSupportFlags = 1;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_VOTE_BIT: WaveOpsSupportFlags = 2;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_ARITHMETIC_BIT: WaveOpsSupportFlags = 4;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_BALLOT_BIT: WaveOpsSupportFlags = 8;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_SHUFFLE_BIT: WaveOpsSupportFlags = 16;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_SHUFFLE_RELATIVE_BIT: WaveOpsSupportFlags = 32;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_CLUSTERED_BIT: WaveOpsSupportFlags = 64;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_QUAD_BIT: WaveOpsSupportFlags = 128;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_PARTITIONED_BIT_NV: WaveOpsSupportFlags = 256;
pub const WaveOpsSupportFlags_WAVE_OPS_SUPPORT_FLAG_ALL: WaveOpsSupportFlags = 2147483647;
pub type WaveOpsSupportFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPUSettings {
    pub mUniformBufferAlignment: u32,
    pub mUploadBufferTextureAlignment: u32,
    pub mUploadBufferTextureRowAlignment: u32,
    pub mMaxVertexInputBindings: u32,
    pub mMaxRootSignatureDWORDS: u32,
    pub mWaveLaneCount: u32,
    pub mWaveOpsSupportFlags: WaveOpsSupportFlags,
    pub mGpuVendorPreset: GPUVendorPreset,
    pub mShadingRates: ShadingRate,
    pub mShadingRateCaps: ShadingRateCaps,
    pub mShadingRateTexelWidth: u32,
    pub mShadingRateTexelHeight: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_GPUSettings() {
    assert_eq!(
        ::std::mem::size_of::<GPUSettings>(),
        436usize,
        concat!("Size of: ", stringify!(GPUSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<GPUSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(GPUSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mUniformBufferAlignment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mUniformBufferAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mUploadBufferTextureAlignment as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mUploadBufferTextureAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mUploadBufferTextureRowAlignment as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mUploadBufferTextureRowAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mMaxVertexInputBindings as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mMaxVertexInputBindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mMaxRootSignatureDWORDS as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mMaxRootSignatureDWORDS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mWaveLaneCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mWaveLaneCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mWaveOpsSupportFlags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mWaveOpsSupportFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mGpuVendorPreset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mGpuVendorPreset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mShadingRates as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mShadingRates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mShadingRateCaps as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mShadingRateCaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mShadingRateTexelWidth as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mShadingRateTexelWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPUSettings>())).mShadingRateTexelHeight as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(GPUSettings),
            "::",
            stringify!(mShadingRateTexelHeight)
        )
    );
}
impl GPUSettings {
    #[inline]
    pub fn mMultiDrawIndirect(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mMultiDrawIndirect(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mROVsSupported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mROVsSupported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mTessellationSupported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mTessellationSupported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mGeometryShaderSupported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mGeometryShaderSupported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mGpuBreadcrumbs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mGpuBreadcrumbs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mHDRSupported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mHDRSupported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mMultiDrawIndirect: u32,
        mROVsSupported: u32,
        mTessellationSupported: u32,
        mGeometryShaderSupported: u32,
        mGpuBreadcrumbs: u32,
        mHDRSupported: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mMultiDrawIndirect: u32 = unsafe { ::std::mem::transmute(mMultiDrawIndirect) };
            mMultiDrawIndirect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mROVsSupported: u32 = unsafe { ::std::mem::transmute(mROVsSupported) };
            mROVsSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mTessellationSupported: u32 = unsafe { ::std::mem::transmute(mTessellationSupported) };
            mTessellationSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mGeometryShaderSupported: u32 = unsafe { ::std::mem::transmute(mGeometryShaderSupported) };
            mGeometryShaderSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mGpuBreadcrumbs: u32 = unsafe { ::std::mem::transmute(mGpuBreadcrumbs) };
            mGpuBreadcrumbs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mHDRSupported: u32 = unsafe { ::std::mem::transmute(mHDRSupported) };
            mHDRSupported as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectArgument {
    pub mType: IndirectArgumentType,
    pub mOffset: u32,
}
#[test]
fn bindgen_test_layout_IndirectArgument() {
    assert_eq!(
        ::std::mem::size_of::<IndirectArgument>(),
        8usize,
        concat!("Size of: ", stringify!(IndirectArgument))
    );
    assert_eq!(
        ::std::mem::align_of::<IndirectArgument>(),
        4usize,
        concat!("Alignment of ", stringify!(IndirectArgument))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectArgument>())).mType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectArgument),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectArgument>())).mOffset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectArgument),
            "::",
            stringify!(mOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectArgumentDescriptor {
    pub mType: IndirectArgumentType,
    pub pName: *const ::std::os::raw::c_char,
    pub mIndex: u32,
    pub mByteSize: u32,
}
#[test]
fn bindgen_test_layout_IndirectArgumentDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<IndirectArgumentDescriptor>(),
        24usize,
        concat!("Size of: ", stringify!(IndirectArgumentDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<IndirectArgumentDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(IndirectArgumentDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectArgumentDescriptor>())).mType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectArgumentDescriptor),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectArgumentDescriptor>())).pName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectArgumentDescriptor),
            "::",
            stringify!(pName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectArgumentDescriptor>())).mIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectArgumentDescriptor),
            "::",
            stringify!(mIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndirectArgumentDescriptor>())).mByteSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IndirectArgumentDescriptor),
            "::",
            stringify!(mByteSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandSignatureDesc {
    pub pRootSignature: *mut RootSignature,
    pub pArgDescs: *mut IndirectArgumentDescriptor,
    pub mIndirectArgCount: u32,
    #[doc = " Set to true if indirect argument struct should not be aligned to 16 bytes"]
    pub mPacked: bool,
}
#[test]
fn bindgen_test_layout_CommandSignatureDesc() {
    assert_eq!(
        ::std::mem::size_of::<CommandSignatureDesc>(),
        24usize,
        concat!("Size of: ", stringify!(CommandSignatureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<CommandSignatureDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(CommandSignatureDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandSignatureDesc>())).pRootSignature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandSignatureDesc),
            "::",
            stringify!(pRootSignature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandSignatureDesc>())).pArgDescs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandSignatureDesc),
            "::",
            stringify!(pArgDescs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandSignatureDesc>())).mIndirectArgCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandSignatureDesc),
            "::",
            stringify!(mIndirectArgCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandSignatureDesc>())).mPacked as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandSignatureDesc),
            "::",
            stringify!(mPacked)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandSignature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetDesc {
    pub pRootSignature: *mut RootSignature,
    pub mUpdateFrequency: DescriptorUpdateFrequency,
    pub mMaxSets: u32,
    pub mNodeIndex: u32,
}
#[test]
fn bindgen_test_layout_DescriptorSetDesc() {
    assert_eq!(
        ::std::mem::size_of::<DescriptorSetDesc>(),
        24usize,
        concat!("Size of: ", stringify!(DescriptorSetDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<DescriptorSetDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(DescriptorSetDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorSetDesc>())).pRootSignature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorSetDesc),
            "::",
            stringify!(pRootSignature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorSetDesc>())).mUpdateFrequency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorSetDesc),
            "::",
            stringify!(mUpdateFrequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorSetDesc>())).mMaxSets as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorSetDesc),
            "::",
            stringify!(mMaxSets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DescriptorSetDesc>())).mNodeIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DescriptorSetDesc),
            "::",
            stringify!(mNodeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueSubmitDesc {
    pub ppCmds: *mut *mut Cmd,
    pub pSignalFence: *mut Fence,
    pub ppWaitSemaphores: *mut *mut Semaphore,
    pub ppSignalSemaphores: *mut *mut Semaphore,
    pub mCmdCount: u32,
    pub mWaitSemaphoreCount: u32,
    pub mSignalSemaphoreCount: u32,
    pub mSubmitDone: bool,
}
#[test]
fn bindgen_test_layout_QueueSubmitDesc() {
    assert_eq!(
        ::std::mem::size_of::<QueueSubmitDesc>(),
        48usize,
        concat!("Size of: ", stringify!(QueueSubmitDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<QueueSubmitDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(QueueSubmitDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).ppCmds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(ppCmds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).pSignalFence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(pSignalFence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).ppWaitSemaphores as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(ppWaitSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).ppSignalSemaphores as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(ppSignalSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).mCmdCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(mCmdCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).mWaitSemaphoreCount as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(mWaitSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).mSignalSemaphoreCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(mSignalSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueueSubmitDesc>())).mSubmitDone as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(QueueSubmitDesc),
            "::",
            stringify!(mSubmitDone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueuePresentDesc {
    pub pSwapChain: *mut SwapChain,
    pub ppWaitSemaphores: *mut *mut Semaphore,
    pub mWaitSemaphoreCount: u32,
    pub mIndex: u8,
    pub mSubmitDone: bool,
}
#[test]
fn bindgen_test_layout_QueuePresentDesc() {
    assert_eq!(
        ::std::mem::size_of::<QueuePresentDesc>(),
        24usize,
        concat!("Size of: ", stringify!(QueuePresentDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<QueuePresentDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(QueuePresentDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueuePresentDesc>())).pSwapChain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QueuePresentDesc),
            "::",
            stringify!(pSwapChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueuePresentDesc>())).ppWaitSemaphores as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QueuePresentDesc),
            "::",
            stringify!(ppWaitSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueuePresentDesc>())).mWaitSemaphoreCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QueuePresentDesc),
            "::",
            stringify!(mWaitSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueuePresentDesc>())).mIndex as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(QueuePresentDesc),
            "::",
            stringify!(mIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueuePresentDesc>())).mSubmitDone as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(QueuePresentDesc),
            "::",
            stringify!(mSubmitDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?initRenderer@@YAXPEBDPEBURendererDesc@@PEAPEAURenderer@@@Z"]
    pub fn initRenderer(
        app_name: *const ::std::os::raw::c_char,
        p_settings: *const RendererDesc,
        pRenderer: *mut *mut Renderer,
    );
}
extern "C" {
    #[link_name = "\u{1}?exitRenderer@@YAXPEAURenderer@@@Z"]
    pub fn exitRenderer(pRenderer: *mut Renderer);
}
pub type addFenceFn = ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_fence: *mut *mut Fence)>;
extern "C" {
    #[link_name = "\u{1}?addFence@@3P6AXPEAURenderer@@PEAPEAUFence@@@ZEA"]
    pub static mut addFence: addFenceFn;
}
pub type removeFenceFn = ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_fence: *mut Fence)>;
extern "C" {
    #[link_name = "\u{1}?removeFence@@3P6AXPEAURenderer@@PEAUFence@@@ZEA"]
    pub static mut removeFence: removeFenceFn;
}
pub type addSemaphoreFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_semaphore: *mut *mut Semaphore)>;
extern "C" {
    #[link_name = "\u{1}?addSemaphore@@3P6AXPEAURenderer@@PEAPEAUSemaphore@@@ZEA"]
    pub static mut addSemaphore: addSemaphoreFn;
}
pub type removeSemaphoreFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_semaphore: *mut Semaphore)>;
extern "C" {
    #[link_name = "\u{1}?removeSemaphore@@3P6AXPEAURenderer@@PEAUSemaphore@@@ZEA"]
    pub static mut removeSemaphore: removeSemaphoreFn;
}
pub type addQueueFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, pQDesc: *mut QueueDesc, pQueue: *mut *mut Queue),
>;
extern "C" {
    #[link_name = "\u{1}?addQueue@@3P6AXPEAURenderer@@PEAUQueueDesc@@PEAPEAUQueue@@@ZEA"]
    pub static mut addQueue: addQueueFn;
}
pub type removeQueueFn = ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pQueue: *mut Queue)>;
extern "C" {
    #[link_name = "\u{1}?removeQueue@@3P6AXPEAURenderer@@PEAUQueue@@@ZEA"]
    pub static mut removeQueue: removeQueueFn;
}
pub type addSwapChainFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, p_desc: *const SwapChainDesc, p_swap_chain: *mut *mut SwapChain),
>;
extern "C" {
    #[link_name = "\u{1}?addSwapChain@@3P6AXPEAURenderer@@PEBUSwapChainDesc@@PEAPEAUSwapChain@@@ZEA"]
    pub static mut addSwapChain: addSwapChainFn;
}
pub type removeSwapChainFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_swap_chain: *mut SwapChain)>;
extern "C" {
    #[link_name = "\u{1}?removeSwapChain@@3P6AXPEAURenderer@@PEAUSwapChain@@@ZEA"]
    pub static mut removeSwapChain: removeSwapChainFn;
}
pub type addCmdPoolFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, p_desc: *const CmdPoolDesc, p_cmd_pool: *mut *mut CmdPool),
>;
extern "C" {
    #[link_name = "\u{1}?addCmdPool@@3P6AXPEAURenderer@@PEBUCmdPoolDesc@@PEAPEAUCmdPool@@@ZEA"]
    pub static mut addCmdPool: addCmdPoolFn;
}
pub type removeCmdPoolFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_CmdPool: *mut CmdPool)>;
extern "C" {
    #[link_name = "\u{1}?removeCmdPool@@3P6AXPEAURenderer@@PEAUCmdPool@@@ZEA"]
    pub static mut removeCmdPool: removeCmdPoolFn;
}
pub type addCmdFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_desc: *const CmdDesc, p_cmd: *mut *mut Cmd)>;
extern "C" {
    #[link_name = "\u{1}?addCmd@@3P6AXPEAURenderer@@PEBUCmdDesc@@PEAPEAUCmd@@@ZEA"]
    pub static mut addCmd: addCmdFn;
}
pub type removeCmdFn = ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pCmd: *mut Cmd)>;
extern "C" {
    #[link_name = "\u{1}?removeCmd@@3P6AXPEAURenderer@@PEAUCmd@@@ZEA"]
    pub static mut removeCmd: removeCmdFn;
}
pub type addCmd_nFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, p_desc: *const CmdDesc, cmd_count: u32, p_cmds: *mut *mut *mut Cmd),
>;
extern "C" {
    #[link_name = "\u{1}?addCmd_n@@3P6AXPEAURenderer@@PEBUCmdDesc@@IPEAPEAPEAUCmd@@@ZEA"]
    pub static mut addCmd_n: addCmd_nFn;
}
pub type removeCmd_nFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, cmd_count: u32, p_cmds: *mut *mut Cmd)>;
extern "C" {
    #[link_name = "\u{1}?removeCmd_n@@3P6AXPEAURenderer@@IPEAPEAUCmd@@@ZEA"]
    pub static mut removeCmd_n: removeCmd_nFn;
}
pub type addRenderTargetFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        pDesc: *const RenderTargetDesc,
        ppRenderTarget: *mut *mut RenderTarget,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?addRenderTarget@@3P6AXPEAURenderer@@PEBURenderTargetDesc@@PEAPEAURenderTarget@@@ZEA"]
    pub static mut addRenderTarget: addRenderTargetFn;
}
pub type removeRenderTargetFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pRenderTarget: *mut RenderTarget)>;
extern "C" {
    #[link_name = "\u{1}?removeRenderTarget@@3P6AXPEAURenderer@@PEAURenderTarget@@@ZEA"]
    pub static mut removeRenderTarget: removeRenderTargetFn;
}
pub type addSamplerFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, pDesc: *const SamplerDesc, p_sampler: *mut *mut Sampler),
>;
extern "C" {
    #[link_name = "\u{1}?addSampler@@3P6AXPEAURenderer@@PEBUSamplerDesc@@PEAPEAUSampler@@@ZEA"]
    pub static mut addSampler: addSamplerFn;
}
pub type removeSamplerFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_sampler: *mut Sampler)>;
extern "C" {
    #[link_name = "\u{1}?removeSampler@@3P6AXPEAURenderer@@PEAUSampler@@@ZEA"]
    pub static mut removeSampler: removeSamplerFn;
}
pub type addShaderBinaryFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, p_desc: *const BinaryShaderDesc, p_shader_program: *mut *mut Shader),
>;
extern "C" {
    #[link_name = "\u{1}?addShaderBinary@@3P6AXPEAURenderer@@PEBUBinaryShaderDesc@@PEAPEAUShader@@@ZEA"]
    pub static mut addShaderBinary: addShaderBinaryFn;
}
pub type removeShaderFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_shader_program: *mut Shader)>;
extern "C" {
    #[link_name = "\u{1}?removeShader@@3P6AXPEAURenderer@@PEAUShader@@@ZEA"]
    pub static mut removeShader: removeShaderFn;
}
pub type addRootSignatureFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        pDesc: *const RootSignatureDesc,
        pRootSignature: *mut *mut RootSignature,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?addRootSignature@@3P6AXPEAURenderer@@PEBURootSignatureDesc@@PEAPEAURootSignature@@@ZEA"]
    pub static mut addRootSignature: addRootSignatureFn;
}
pub type removeRootSignatureFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pRootSignature: *mut RootSignature)>;
extern "C" {
    #[link_name = "\u{1}?removeRootSignature@@3P6AXPEAURenderer@@PEAURootSignature@@@ZEA"]
    pub static mut removeRootSignature: removeRootSignatureFn;
}
pub type addPipelineFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        p_pipeline_settings: *const PipelineDesc,
        p_pipeline: *mut *mut Pipeline,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?addPipeline@@3P6AXPEAURenderer@@PEBUPipelineDesc@@PEAPEAUPipeline@@@ZEA"]
    pub static mut addPipeline: addPipelineFn;
}
pub type removePipelineFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, p_pipeline: *mut Pipeline)>;
extern "C" {
    #[link_name = "\u{1}?removePipeline@@3P6AXPEAURenderer@@PEAUPipeline@@@ZEA"]
    pub static mut removePipeline: removePipelineFn;
}
pub type addPipelineCacheFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        pDesc: *const PipelineCacheDesc,
        ppPipelineCache: *mut *mut PipelineCache,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?addPipelineCache@@3P6AXPEAURenderer@@PEBUPipelineCacheDesc@@PEAPEAUPipelineCache@@@ZEA"]
    pub static mut addPipelineCache: addPipelineCacheFn;
}
pub type getPipelineCacheDataFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        pPipelineCache: *mut PipelineCache,
        pSize: *mut usize,
        pData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?getPipelineCacheData@@3P6AXPEAURenderer@@PEAUPipelineCache@@PEA_KPEAX@ZEA"]
    pub static mut getPipelineCacheData: getPipelineCacheDataFn;
}
pub type removePipelineCacheFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pPipelineCache: *mut PipelineCache)>;
extern "C" {
    #[link_name = "\u{1}?removePipelineCache@@3P6AXPEAURenderer@@PEAUPipelineCache@@@ZEA"]
    pub static mut removePipelineCache: removePipelineCacheFn;
}
pub type addDescriptorSetFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        pDesc: *const DescriptorSetDesc,
        pDescriptorSet: *mut *mut DescriptorSet,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?addDescriptorSet@@3P6AXPEAURenderer@@PEBUDescriptorSetDesc@@PEAPEAUDescriptorSet@@@ZEA"]
    pub static mut addDescriptorSet: addDescriptorSetFn;
}
pub type removeDescriptorSetFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pDescriptorSet: *mut DescriptorSet)>;
extern "C" {
    #[link_name = "\u{1}?removeDescriptorSet@@3P6AXPEAURenderer@@PEAUDescriptorSet@@@ZEA"]
    pub static mut removeDescriptorSet: removeDescriptorSetFn;
}
pub type updateDescriptorSetFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        index: u32,
        pDescriptorSet: *mut DescriptorSet,
        count: u32,
        pParams: *const DescriptorData,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?updateDescriptorSet@@3P6AXPEAURenderer@@IPEAUDescriptorSet@@IPEBUDescriptorData@@@ZEA"]
    pub static mut updateDescriptorSet: updateDescriptorSetFn;
}
pub type resetCmdPoolFn = ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pCmdPool: *mut CmdPool)>;
extern "C" {
    #[link_name = "\u{1}?resetCmdPool@@3P6AXPEAURenderer@@PEAUCmdPool@@@ZEA"]
    pub static mut resetCmdPool: resetCmdPoolFn;
}
pub type beginCmdFn = ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd)>;
extern "C" {
    #[link_name = "\u{1}?beginCmd@@3P6AXPEAUCmd@@@ZEA"]
    pub static mut beginCmd: beginCmdFn;
}
pub type endCmdFn = ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd)>;
extern "C" {
    #[link_name = "\u{1}?endCmd@@3P6AXPEAUCmd@@@ZEA"]
    pub static mut endCmd: endCmdFn;
}
pub type cmdBindRenderTargetsFn = ::std::option::Option<
    unsafe extern "C" fn(
        p_cmd: *mut Cmd,
        render_target_count: u32,
        p_render_targets: *mut *mut RenderTarget,
        p_depth_stencil: *mut RenderTarget,
        loadActions: *const LoadActionsDesc,
        pColorArraySlices: *mut u32,
        pColorMipSlices: *mut u32,
        depthArraySlice: u32,
        depthMipSlice: u32,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdBindRenderTargets@@3P6AXPEAUCmd@@IPEAPEAURenderTarget@@PEAU2@PEBULoadActionsDesc@@PEAI4II@ZEA"]
    pub static mut cmdBindRenderTargets: cmdBindRenderTargetsFn;
}
pub type cmdSetShadingRateFn = ::std::option::Option<
    unsafe extern "C" fn(
        p_cmd: *mut Cmd,
        shading_rate: ShadingRate,
        p_texture: *mut Texture,
        post_rasterizer_rate: ShadingRateCombiner,
        final_rate: ShadingRateCombiner,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdSetShadingRate@@3P6AXPEAUCmd@@W4ShadingRate@@PEAUTexture@@W4ShadingRateCombiner@@3@ZEA"]
    pub static mut cmdSetShadingRate: cmdSetShadingRateFn;
}
pub type cmdSetViewportFn = ::std::option::Option<
    unsafe extern "C" fn(p_cmd: *mut Cmd, x: f32, y: f32, width: f32, height: f32, min_depth: f32, max_depth: f32),
>;
extern "C" {
    #[link_name = "\u{1}?cmdSetViewport@@3P6AXPEAUCmd@@MMMMMM@ZEA"]
    pub static mut cmdSetViewport: cmdSetViewportFn;
}
pub type cmdSetScissorFn =
    ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd, x: u32, y: u32, width: u32, height: u32)>;
extern "C" {
    #[link_name = "\u{1}?cmdSetScissor@@3P6AXPEAUCmd@@IIII@ZEA"]
    pub static mut cmdSetScissor: cmdSetScissorFn;
}
pub type cmdSetStencilReferenceValueFn = ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd, val: u32)>;
extern "C" {
    #[link_name = "\u{1}?cmdSetStencilReferenceValue@@3P6AXPEAUCmd@@I@ZEA"]
    pub static mut cmdSetStencilReferenceValue: cmdSetStencilReferenceValueFn;
}
pub type cmdBindPipelineFn = ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd, p_pipeline: *mut Pipeline)>;
extern "C" {
    #[link_name = "\u{1}?cmdBindPipeline@@3P6AXPEAUCmd@@PEAUPipeline@@@ZEA"]
    pub static mut cmdBindPipeline: cmdBindPipelineFn;
}
pub type cmdBindDescriptorSetFn =
    ::std::option::Option<unsafe extern "C" fn(pCmd: *mut Cmd, index: u32, pDescriptorSet: *mut DescriptorSet)>;
extern "C" {
    #[link_name = "\u{1}?cmdBindDescriptorSet@@3P6AXPEAUCmd@@IPEAUDescriptorSet@@@ZEA"]
    pub static mut cmdBindDescriptorSet: cmdBindDescriptorSetFn;
}
pub type cmdBindPushConstantsFn = ::std::option::Option<
    unsafe extern "C" fn(
        pCmd: *mut Cmd,
        pRootSignature: *mut RootSignature,
        pName: *const ::std::os::raw::c_char,
        pConstants: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdBindPushConstants@@3P6AXPEAUCmd@@PEAURootSignature@@PEBDPEBX@ZEA"]
    pub static mut cmdBindPushConstants: cmdBindPushConstantsFn;
}
pub type cmdBindPushConstantsByIndexFn = ::std::option::Option<
    unsafe extern "C" fn(
        pCmd: *mut Cmd,
        pRootSignature: *mut RootSignature,
        paramIndex: u32,
        pConstants: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdBindPushConstantsByIndex@@3P6AXPEAUCmd@@PEAURootSignature@@IPEBX@ZEA"]
    pub static mut cmdBindPushConstantsByIndex: cmdBindPushConstantsByIndexFn;
}
pub type cmdBindIndexBufferFn =
    ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd, p_buffer: *mut Buffer, indexType: u32, offset: u64)>;
extern "C" {
    #[link_name = "\u{1}?cmdBindIndexBuffer@@3P6AXPEAUCmd@@PEAUBuffer@@I_K@ZEA"]
    pub static mut cmdBindIndexBuffer: cmdBindIndexBufferFn;
}
pub type cmdBindVertexBufferFn = ::std::option::Option<
    unsafe extern "C" fn(
        p_cmd: *mut Cmd,
        buffer_count: u32,
        pp_buffers: *mut *mut Buffer,
        pStrides: *const u32,
        pOffsets: *const u64,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdBindVertexBuffer@@3P6AXPEAUCmd@@IPEAPEAUBuffer@@PEBIPEB_K@ZEA"]
    pub static mut cmdBindVertexBuffer: cmdBindVertexBufferFn;
}
pub type cmdDrawFn = ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd, vertex_count: u32, first_vertex: u32)>;
extern "C" {
    #[link_name = "\u{1}?cmdDraw@@3P6AXPEAUCmd@@II@ZEA"]
    pub static mut cmdDraw: cmdDrawFn;
}
pub type cmdDrawInstancedFn = ::std::option::Option<
    unsafe extern "C" fn(pCmd: *mut Cmd, vertexCount: u32, firstVertex: u32, instanceCount: u32, firstInstance: u32),
>;
extern "C" {
    #[link_name = "\u{1}?cmdDrawInstanced@@3P6AXPEAUCmd@@IIII@ZEA"]
    pub static mut cmdDrawInstanced: cmdDrawInstancedFn;
}
pub type cmdDrawIndexedFn =
    ::std::option::Option<unsafe extern "C" fn(p_cmd: *mut Cmd, index_count: u32, first_index: u32, first_vertex: u32)>;
extern "C" {
    #[link_name = "\u{1}?cmdDrawIndexed@@3P6AXPEAUCmd@@III@ZEA"]
    pub static mut cmdDrawIndexed: cmdDrawIndexedFn;
}
pub type cmdDrawIndexedInstancedFn = ::std::option::Option<
    unsafe extern "C" fn(
        pCmd: *mut Cmd,
        indexCount: u32,
        firstIndex: u32,
        instanceCount: u32,
        firstVertex: u32,
        firstInstance: u32,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdDrawIndexedInstanced@@3P6AXPEAUCmd@@IIIII@ZEA"]
    pub static mut cmdDrawIndexedInstanced: cmdDrawIndexedInstancedFn;
}
pub type cmdDispatchFn = ::std::option::Option<
    unsafe extern "C" fn(p_cmd: *mut Cmd, group_count_x: u32, group_count_y: u32, group_count_z: u32),
>;
extern "C" {
    #[link_name = "\u{1}?cmdDispatch@@3P6AXPEAUCmd@@III@ZEA"]
    pub static mut cmdDispatch: cmdDispatchFn;
}
pub type cmdResourceBarrierFn = ::std::option::Option<
    unsafe extern "C" fn(
        p_cmd: *mut Cmd,
        buffer_barrier_count: u32,
        p_buffer_barriers: *mut BufferBarrier,
        texture_barrier_count: u32,
        p_texture_barriers: *mut TextureBarrier,
        rt_barrier_count: u32,
        p_rt_barriers: *mut RenderTargetBarrier,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdResourceBarrier@@3P6AXPEAUCmd@@IPEAUBufferBarrier@@IPEAUTextureBarrier@@IPEAURenderTargetBarrier@@@ZEA"]
    pub static mut cmdResourceBarrier: cmdResourceBarrierFn;
}
pub type cmdUpdateVirtualTextureFn =
    ::std::option::Option<unsafe extern "C" fn(pCmd: *mut Cmd, pTexture: *mut Texture, currentImage: u32)>;
extern "C" {
    #[link_name = "\u{1}?cmdUpdateVirtualTexture@@3P6AXPEAUCmd@@PEAUTexture@@I@ZEA"]
    pub static mut cmdUpdateVirtualTexture: cmdUpdateVirtualTextureFn;
}
pub type acquireNextImageFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        p_swap_chain: *mut SwapChain,
        p_signal_semaphore: *mut Semaphore,
        p_fence: *mut Fence,
        p_image_index: *mut u32,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?acquireNextImage@@3P6AXPEAURenderer@@PEAUSwapChain@@PEAUSemaphore@@PEAUFence@@PEAI@ZEA"]
    pub static mut acquireNextImage: acquireNextImageFn;
}
pub type queueSubmitFn =
    ::std::option::Option<unsafe extern "C" fn(p_queue: *mut Queue, p_desc: *const QueueSubmitDesc)>;
extern "C" {
    #[link_name = "\u{1}?queueSubmit@@3P6AXPEAUQueue@@PEBUQueueSubmitDesc@@@ZEA"]
    pub static mut queueSubmit: queueSubmitFn;
}
pub type queuePresentFn =
    ::std::option::Option<unsafe extern "C" fn(p_queue: *mut Queue, p_desc: *const QueuePresentDesc)>;
extern "C" {
    #[link_name = "\u{1}?queuePresent@@3P6AXPEAUQueue@@PEBUQueuePresentDesc@@@ZEA"]
    pub static mut queuePresent: queuePresentFn;
}
pub type waitQueueIdleFn = ::std::option::Option<unsafe extern "C" fn(p_queue: *mut Queue)>;
extern "C" {
    #[link_name = "\u{1}?waitQueueIdle@@3P6AXPEAUQueue@@@ZEA"]
    pub static mut waitQueueIdle: waitQueueIdleFn;
}
pub type getFenceStatusFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, p_fence: *mut Fence, p_fence_status: *mut FenceStatus),
>;
extern "C" {
    #[link_name = "\u{1}?getFenceStatus@@3P6AXPEAURenderer@@PEAUFence@@PEAW4FenceStatus@@@ZEA"]
    pub static mut getFenceStatus: getFenceStatusFn;
}
pub type waitForFencesFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, fenceCount: u32, ppFences: *mut *mut Fence)>;
extern "C" {
    #[link_name = "\u{1}?waitForFences@@3P6AXPEAURenderer@@IPEAPEAUFence@@@ZEA"]
    pub static mut waitForFences: waitForFencesFn;
}
pub type toggleVSyncFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, ppSwapchain: *mut *mut SwapChain)>;
extern "C" {
    #[link_name = "\u{1}?toggleVSync@@3P6AXPEAURenderer@@PEAPEAUSwapChain@@@ZEA"]
    pub static mut toggleVSync: toggleVSyncFn;
}
pub type getRecommendedSwapchainFormatFn =
    ::std::option::Option<unsafe extern "C" fn(hintHDR: bool) -> TinyImageFormat>;
extern "C" {
    #[link_name = "\u{1}?getRecommendedSwapchainFormat@@3P6A?AW4TinyImageFormat@@_N@ZEA"]
    pub static mut getRecommendedSwapchainFormat: getRecommendedSwapchainFormatFn;
}
pub type addIndirectCommandSignatureFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        p_desc: *const CommandSignatureDesc,
        ppCommandSignature: *mut *mut CommandSignature,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?addIndirectCommandSignature@@3P6AXPEAURenderer@@PEBUCommandSignatureDesc@@PEAPEAUCommandSignature@@@ZEA"]
    pub static mut addIndirectCommandSignature: addIndirectCommandSignatureFn;
}
pub type removeIndirectCommandSignatureFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pCommandSignature: *mut CommandSignature)>;
extern "C" {
    #[link_name = "\u{1}?removeIndirectCommandSignature@@3P6AXPEAURenderer@@PEAUCommandSignature@@@ZEA"]
    pub static mut removeIndirectCommandSignature: removeIndirectCommandSignatureFn;
}
pub type cmdExecuteIndirectFn = ::std::option::Option<
    unsafe extern "C" fn(
        pCmd: *mut Cmd,
        pCommandSignature: *mut CommandSignature,
        maxCommandCount: ::std::os::raw::c_uint,
        pIndirectBuffer: *mut Buffer,
        bufferOffset: u64,
        pCounterBuffer: *mut Buffer,
        counterBufferOffset: u64,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdExecuteIndirect@@3P6AXPEAUCmd@@PEAUCommandSignature@@IPEAUBuffer@@_K23@ZEA"]
    pub static mut cmdExecuteIndirect: cmdExecuteIndirectFn;
}
pub type getTimestampFrequencyFn =
    ::std::option::Option<unsafe extern "C" fn(pQueue: *mut Queue, pFrequency: *mut f64)>;
extern "C" {
    #[link_name = "\u{1}?getTimestampFrequency@@3P6AXPEAUQueue@@PEAN@ZEA"]
    pub static mut getTimestampFrequency: getTimestampFrequencyFn;
}
pub type addQueryPoolFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, pDesc: *const QueryPoolDesc, ppQueryPool: *mut *mut QueryPool),
>;
extern "C" {
    #[link_name = "\u{1}?addQueryPool@@3P6AXPEAURenderer@@PEBUQueryPoolDesc@@PEAPEAUQueryPool@@@ZEA"]
    pub static mut addQueryPool: addQueryPoolFn;
}
pub type removeQueryPoolFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, pQueryPool: *mut QueryPool)>;
extern "C" {
    #[link_name = "\u{1}?removeQueryPool@@3P6AXPEAURenderer@@PEAUQueryPool@@@ZEA"]
    pub static mut removeQueryPool: removeQueryPoolFn;
}
pub type cmdResetQueryPoolFn = ::std::option::Option<
    unsafe extern "C" fn(pCmd: *mut Cmd, pQueryPool: *mut QueryPool, startQuery: u32, queryCount: u32),
>;
extern "C" {
    #[link_name = "\u{1}?cmdResetQueryPool@@3P6AXPEAUCmd@@PEAUQueryPool@@II@ZEA"]
    pub static mut cmdResetQueryPool: cmdResetQueryPoolFn;
}
pub type cmdBeginQueryFn =
    ::std::option::Option<unsafe extern "C" fn(pCmd: *mut Cmd, pQueryPool: *mut QueryPool, pQuery: *mut QueryDesc)>;
extern "C" {
    #[link_name = "\u{1}?cmdBeginQuery@@3P6AXPEAUCmd@@PEAUQueryPool@@PEAUQueryDesc@@@ZEA"]
    pub static mut cmdBeginQuery: cmdBeginQueryFn;
}
pub type cmdEndQueryFn =
    ::std::option::Option<unsafe extern "C" fn(pCmd: *mut Cmd, pQueryPool: *mut QueryPool, pQuery: *mut QueryDesc)>;
extern "C" {
    #[link_name = "\u{1}?cmdEndQuery@@3P6AXPEAUCmd@@PEAUQueryPool@@PEAUQueryDesc@@@ZEA"]
    pub static mut cmdEndQuery: cmdEndQueryFn;
}
pub type cmdResolveQueryFn = ::std::option::Option<
    unsafe extern "C" fn(
        pCmd: *mut Cmd,
        pQueryPool: *mut QueryPool,
        pReadbackBuffer: *mut Buffer,
        startQuery: u32,
        queryCount: u32,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?cmdResolveQuery@@3P6AXPEAUCmd@@PEAUQueryPool@@PEAUBuffer@@II@ZEA"]
    pub static mut cmdResolveQuery: cmdResolveQueryFn;
}
pub type calculateMemoryStatsFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, stats: *mut *mut ::std::os::raw::c_char)>;
extern "C" {
    #[link_name = "\u{1}?calculateMemoryStats@@3P6AXPEAURenderer@@PEAPEAD@ZEA"]
    pub static mut calculateMemoryStats: calculateMemoryStatsFn;
}
pub type calculateMemoryUseFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, usedBytes: *mut u64, totalAllocatedBytes: *mut u64),
>;
extern "C" {
    #[link_name = "\u{1}?calculateMemoryUse@@3P6AXPEAURenderer@@PEA_K1@ZEA"]
    pub static mut calculateMemoryUse: calculateMemoryUseFn;
}
pub type freeMemoryStatsFn =
    ::std::option::Option<unsafe extern "C" fn(pRenderer: *mut Renderer, stats: *mut ::std::os::raw::c_char)>;
extern "C" {
    #[link_name = "\u{1}?freeMemoryStats@@3P6AXPEAURenderer@@PEAD@ZEA"]
    pub static mut freeMemoryStats: freeMemoryStatsFn;
}
pub type cmdBeginDebugMarkerFn = ::std::option::Option<
    unsafe extern "C" fn(pCmd: *mut Cmd, r: f32, g: f32, b: f32, pName: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[link_name = "\u{1}?cmdBeginDebugMarker@@3P6AXPEAUCmd@@MMMPEBD@ZEA"]
    pub static mut cmdBeginDebugMarker: cmdBeginDebugMarkerFn;
}
pub type cmdEndDebugMarkerFn = ::std::option::Option<unsafe extern "C" fn(pCmd: *mut Cmd)>;
extern "C" {
    #[link_name = "\u{1}?cmdEndDebugMarker@@3P6AXPEAUCmd@@@ZEA"]
    pub static mut cmdEndDebugMarker: cmdEndDebugMarkerFn;
}
pub type cmdAddDebugMarkerFn = ::std::option::Option<
    unsafe extern "C" fn(pCmd: *mut Cmd, r: f32, g: f32, b: f32, pName: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[link_name = "\u{1}?cmdAddDebugMarker@@3P6AXPEAUCmd@@MMMPEBD@ZEA"]
    pub static mut cmdAddDebugMarker: cmdAddDebugMarkerFn;
}
pub type cmdWriteMarkerFn = ::std::option::Option<
    unsafe extern "C" fn(
        pCmd: *mut Cmd,
        markerType: MarkerType,
        markerValue: u32,
        pBuffer: *mut Buffer,
        offset: usize,
        useAutoFlags: bool,
    ) -> u32,
>;
extern "C" {
    #[link_name = "\u{1}?cmdWriteMarker@@3P6AIPEAUCmd@@W4MarkerType@@IPEAUBuffer@@_K_N@ZEA"]
    pub static mut cmdWriteMarker: cmdWriteMarkerFn;
}
pub type setBufferNameFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, pBuffer: *mut Buffer, pName: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[link_name = "\u{1}?setBufferName@@3P6AXPEAURenderer@@PEAUBuffer@@PEBD@ZEA"]
    pub static mut setBufferName: setBufferNameFn;
}
pub type setTextureNameFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, pTexture: *mut Texture, pName: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[link_name = "\u{1}?setTextureName@@3P6AXPEAURenderer@@PEAUTexture@@PEBD@ZEA"]
    pub static mut setTextureName: setTextureNameFn;
}
pub type setRenderTargetNameFn = ::std::option::Option<
    unsafe extern "C" fn(
        pRenderer: *mut Renderer,
        pRenderTarget: *mut RenderTarget,
        pName: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[link_name = "\u{1}?setRenderTargetName@@3P6AXPEAURenderer@@PEAURenderTarget@@PEBD@ZEA"]
    pub static mut setRenderTargetName: setRenderTargetNameFn;
}
pub type setPipelineNameFn = ::std::option::Option<
    unsafe extern "C" fn(pRenderer: *mut Renderer, pPipeline: *mut Pipeline, pName: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[link_name = "\u{1}?setPipelineName@@3P6AXPEAURenderer@@PEAUPipeline@@PEBD@ZEA"]
    pub static mut setPipelineName: setPipelineNameFn;
}
